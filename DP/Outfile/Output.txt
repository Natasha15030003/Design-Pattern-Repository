 / Classe abstrata utilizada como base do jogo As sub es devem implementar o método draw @author David Buzatto / public abstract Game Core protected static final int FONT_ SIZE = 24 modos de visualização private static final Display Mode POSSIBLE_ MODES[] = new Display Mode 800 600 16 0 new Display Mode 800 600 32 0 new Display Mode 800 600 24 0 new Display Mode 640 480 16 0 new Display Mode 640 480 32 0 new Display Mode 640 480 24 0 new Display Mode 1024 768 16 0 new Display Mode 1024 768 32 0 new Display Mode 1024 768 24 0 private boolean is Running protected Screen Manager screen / Sinaliza ao loop do jogo que é hora de terminar / public void stop is Running = false / Chama init e game Loop / public void run try init game Loop finally screen restore Screen lazily Exit / Finaliza a máquina virtual usando uma thread daemon A thread daemon aguarda 2 segundos então chama System exit0 Como a máquina virtual deve finalizar apenas quando o daemon estiver rodando isso dá certeza que System exit0 é chamado somente quanto necessário Isso se faz necessário para quando o sistema de som do Java estiver sendo executado / public void lazily Exit Thread thread = new Thread public void run primeiro aguarda que a máquina virtual finaliza por si própria try Thread sleep 2000 catch Interrupted Exception ex o sistema ainda está rodando então força a finalização System exit 0 thread set Daemon true thread start / Configura o modo de tela cheia inicializa e cria os objetos / public void init screen = new Screen Manager Display Mode display Mode = screen find First Compatible Mode POSSIBLE_ MODES screen set Full Screendisplay Mode Window window = screen get Full Screen Window window set Font new Font Dialog Font PLAIN FONT_ SIZE window set Background Color BLUE window set Foreground Color WHITE is Running = true / Carrega uma imagem / public Image load Image name return new Image Icon get Class get Resource /recursos/imagens/ + name get Image / Executa o game loop até que stop seja chamado / public void game Loop long start Time = System current Time Millis long curr Time = start Time while is Running long elapsed Time = System current Time Millis - curr Time curr Time += elapsed Time atualiza update elapsed Time desenha Graphics2 D g = screen get Graphics draw g g dispose screen update não forme executando da forma mais rápida possível /try Thread sleep20 catch Interrupted Exception ex / / Atualiza o estado do jogo/animação baseado da quantidade de tempo que passou / public void updatelong elapsed Time não faz nada / Desenha na tela As sub es devem sobrescrever esse método / public abstract void draw Graphics2 D g  / A e Animation gerencia uma série de imagens quadros e a quantidade de tempo para exibir cada imagem @author David Buzatto / public Animation private Array List< Anim Frame > frames private int curr Frame Index private long anim Time private long total Duration / Cria uma nova Animation vazia / public Animation this new Array List< Anim Frame > 0 / Cria uma animação com os frames e a duração total da exibição da animação / private Animation Array List< Anim Frame > frames long total Duration this frames = frames this total Duration = total Duration start / Cria uma duplicata da animação A lista de frames é compartilhada entre duas animações mas cada animação pode ser animada independentemente / public Object clone return new Animation frames total Duration / Adiciona uma imagem à animação com uma duração especificada tempo para exibir a imagem / public synchronized void add Frame Image image long duration total Duration += duration frames add new Anim Frame image total Duration / Inicia a animação desde o início / public synchronized void start anim Time = 0 curr Frame Index = 0 / Atualiza o quadro atual desta animação se necessário / public synchronized void update long elapsed Time if frames size > 1 anim Time += elapsed Time if anim Time >= total Duration anim Time = anim Time % total Duration curr Frame Index = 0 while anim Time > get Frame curr Frame Index end Time curr Frame Index++ / Obtém a imagem atual da animação Retorna null se a animação não tiver nenhuma imagem / public synchronized Image get Image if frames size == 0 return null else return get Frame curr Frame Index image / Obtém um frame da animação / private Anim Frame get Frame int i return Anim Frame frames get i / Class interna privada que modela um frame quadro da animação / private Anim Frame Image image long end Time / Cria uma novo Anim Frame com uma imagem e o tempo de duração / public Anim Frame Image image long end Time this image = image this end Time = end Time  / O Null Repaint Manager é um Repaint Manager que não faz nenhum repaint É útil quando toda a renderização é feita manualmente pela aplicação @author David Buzatto / public Null Repaint Manager extends Repaint Manager / Instala o Null Repaint Manager / public static void install Repaint Manager repaint Manager = new Null Repaint Manager repaint Manager set Double Buffering Enabled false Repaint Manager set Current Manager repaint Manager public void add Invalid Component J Component c não faz nada public void add Dirty Region J Component c int x int y int w int h não faz nada public void mark Completely Dirty J Component c não faz nada public void paint Dirty Regions não faz nada  / A e Screen Manager gerencia a inicialização e visualização de modos de tela cheia @author David Buzatto / public Screen Manager private Graphics Device device / Cria um novo Screen Manager / public Screen Manager Graphics Environment environment = Graphics Environment get Local Graphics Environment device = environment get Default Screen Device / Retorna uma lista de modos de visualização compatíveis com o dispositivo padrão no sistema / public Display Mode[] get Compatible Display Modes return device get Display Modes / Retorna o primeiro modo compatível da lista de modos Retorna null se nenhum modo é compatível / public Display Mode find First Compatible Mode Display Mode[] modes Display Mode[] good Modes = device get Display Modes for int i = 0 i < modes length i++ for int j = 0 j < good Modes length j++ if display Modes Match modes[ i ] good Modes[ j ] return modes[ i ] return null / Retorna o modo de visualização atual / public Display Mode get Current Display Mode return device get Display Mode / Determina se dois modos de visualização são iguais Dois modos de visualização são iguais se eles têm a mesma resolução profundidade de bits e taxa de atualização A profundidade de bits é ignorada se um dos modos tem uma profundidade de Display Mode BIT_ DEPTH_ MULTI Da mesma forma a taxa de atualização é ignorada se um dos modos de visualização tiver uma taxa de Display Mode REFRESH_ RATE_ UNKNOWN / public boolean display Modes Match Display Mode mode1 Display Mode mode2 if mode1 get Width != mode2 get Width || mode1 get Height != mode2 get Height return false if mode1 get Bit Depth != Display Mode BIT_ DEPTH_ MULTI && mode2 get Bit Depth != Display Mode BIT_ DEPTH_ MULTI && mode1 get Bit Depth != mode2 get Bit Depth return false if mode1 get Refresh Rate != Display Mode REFRESH_ RATE_ UNKNOWN && mode2 get Refresh Rate != Display Mode REFRESH_ RATE_ UNKNOWN && mode1 get Refresh Rate != mode2 get Refresh Rate return false return true / Entra no modo de tela cheia o muda o modo de visualização Se o modo de visualização especificado é null ou não compatível com este dispositivo os o modo de visualização não puder ser alterado nesse sistema o modo de visualização atual é utilizado <p> A visualização usa um Buffer Strategy com 2 buffers / public void set Full Screen Display Mode display Mode final J Frame frame = new J Frame frame set Default Close Operation J Frame EXIT_ ON_ CLOSE frame set Undecorated true frame set Ignore Repaint true frame set Resizable false device set Full Screen Windowframe if display Mode != null && device is Display Change Supported try device set Display Modedisplay Mode catch Illegal Argument Exception ex fix para o Mac OS frame set Sizedisplay Mode get Width display Mode get Height evita deadlock no Java 1 4 try Event Queue invoke And Wait new Runnable public void run frame create Buffer Strategy 2 catch Interrupted Exception ex ignora catch Invocation Target Exception ex ignora / Obtém o contexto gráfico para a visualização O Screen Manager usa double buffering então as aplicações devem chamar update para mostrar qualquer desenho que foi desenhado <p> A aplicação deve dispor do objeto gráfico / public Graphics2 D get Graphics Window window = device get Full Screen Window if window != null Buffer Strategy strategy = window get Buffer Strategy return Graphics2 D strategy get Draw Graphics else return null / Atualiza a visualização / public void update Window window = device get Full Screen Window if window != null Buffer Strategy strategy = window get Buffer Strategy if !strategy contents Lost strategy show sincroniza a visualização em alguns sistemas Toolkit get Default Toolkit sync / Retorna a janela utilizada no modo de tela cheia atual Retorna null se o dispositivo não está no modo de tela cheia / public Window get Full Screen Window return device get Full Screen Window / Retorna a largura da janela usada atualmente no modo de tela cheia Retorna zero se o dispositivo não estiver no modo de tela cheia / public int get Width Window window = device get Full Screen Window if window != null return window get Width else return 0 / Retorna a altura da janela usada atualmente no modo de tela cheia Retorna zero se o dispositivo não estiver no modo de tela cheia / public int get Height Window window = device get Full Screen Window if window != null return window get Height else return 0 / Restaura o modo de visualização da tela / public void restore Screen Window window = device get Full Screen Window if window != null window dispose device set Full Screen Window null / Cria uma imagem compatível com a visualização atual / public Buffered Image create Compatible Image int w int h int transparency Window window = device get Full Screen Window if window != null Graphics Configuration gc = window get Graphics Configuration return gc create Compatible Image w h transparency return null  / A e Sprite define uma entidade do jogo algo que recebe animações @author David Buzatto / public Sprite protected Animation anim posicionamento private float x private float y velocidade pixels por milisegundo private float velocity X private float velocity Y / Cria um novo objeto Sprite com a animação especificada / public Sprite Animation anim this anim = anim / Atualiza a Animação da Sprite e sua posição baseada na velocidade / public void update long elapsed Time x += velocity X elapsed Time y += velocity Y elapsed Time anim update elapsed Time / Obtém a posição x atual da sprite / public float get X return x / Configura a posição x atual da sprite / public void set Xfloat x this x = x / Obtém a posição y atual da sprite / public float get Y return y / Configura a posição x atual da sprite / public void set Yfloat y this y = y / Obtém a velocidade horizontal da sprite em pixels por milisegundo / public float get Velocity X return velocity X / Configura a velocidade horizontal da sprite em pixels por milisegundo / public void set Velocity Xfloat velocity X this velocity X = velocity X / Obtém a velocidade vertical da sprite em pixels por milisegundo / public float get Velocity Y return velocity Y / Configura a velocidade vertical da sprite em pixels por milisegundo / public void set Velocity Yfloat velocity Y this velocity Y = velocity Y / Obtém a largura da Sprite baseado no tamanho da imagem atual / public int get Width return anim get Image get Width null / Obtém a altura da Sprite baseado no tamanho da imagem atual / public int get Height return anim get Image get Height null / Obtém a imagem atual da Sprite / public Image get Image return anim get Image / Clona a Sprite Não clona a posição ou valocidade / public Object clone return new Sprite anim  / Painel de configuração do jogo @author David Buzatto / public Config Panel extends J Panel public Config Panel super set Size 100 100 add new J Button teste public void pain Component Graphics g super paint Component g Graphics2 D g2d = Graphics2 D g g2d set Color Color WHITE g2d fill Rect 0 0 get Width get Height  / A e Game Action é uma abstração para uma ação iniciada pelo usuário como pular ou mover As Game Actions podem ser mapeadas para teclas ou mouse usando o Input Manager @author David Buzatto / public Game Action / Comportamento normal O método is Pressed retorna true quando a tecla é mantida pressionada / public static final int NORMAL = 0 / Comportamento de pressionamento inicial O método is Pressed retorna true somente depois que a tecla é pressionada pela primeira vez e não novamente ate que a tecla seja solta e pressionada novamente / public static final int DETECT_ INITAL_ PRESS_ ONLY = 1 private static final int STATE_ RELEASED = 0 private static final int STATE_ PRESSED = 1 private static final int STATE_ WAITING_ FOR_ RELEASE = 2 private name private int behavior private int amount private int state / Cria uma nova Game Action com comportamento NORMAL / public Game Action name this name NORMAL / Cria uma nova Game Action com o comportamento especificado / public Game Action name int behavior this name = name this behavior = behavior reset / Obtém o nome dessa Game Action / public get Name return name / Reseta esta Game Action fazendo parecer que esta não foi pressionada / public void reset state = STATE_ RELEASED amount = 0 / Pressionamento rápido para essa Game Action O mesmo que chamar press seguido de release / public synchronized void tap press release / Sinaliza que a tecla foi pressionada / public synchronized void press press 1 / Sinaliza que a tecla foi pressionada na quantidade de vezes especificada ou que o mouse se moveu numa distância especificada / public synchronized void press int amount if state != STATE_ WAITING_ FOR_ RELEASE this amount += amount state = STATE_ PRESSED / Sinaliza que a tecla foi solta / public synchronized void release state = STATE_ RELEASED / Retorna se a tecla foi pressionada ou não desde a última checagem / public synchronized boolean is Pressed return get Amount != 0 / Para teclas é a quantidade de vezes que a tecla foi pressionada desde a última vez que foi checada Para eventos do mouse é a distância que cursor foi movido / public synchronized int get Amount int ret Val = amount if ret Val != 0 if state == STATE_ RELEASED amount = 0 else if behavior == DETECT_ INITAL_ PRESS_ ONLY state = STATE_ WAITING_ FOR_ RELEASE amount = 0 return ret Val  / O Input Manager gerencia a entrada de teclas e eventos do mouse Os eventos são mapeados para Game Actions @author David Buzatto / public Input Manager implements Key Listener Mouse Listener Mouse Motion Listener Mouse Wheel Listener / Um cursor invisível / public static final Cursor INVISIBLE_ CURSOR = Toolkit get Default Toolkit create Custom Cursor Toolkit get Default Toolkit get Image new Point 0 0 invisible / Códigos do mouse / public static final int MOUSE_ MOVE_ LEFT = 0 public static final int MOUSE_ MOVE_ RIGHT = 1 public static final int MOUSE_ MOVE_ UP = 2 public static final int MOUSE_ MOVE_ DOWN = 3 public static final int MOUSE_ WHEEL_ UP = 4 public static final int MOUSE_ WHEEL_ DOWN = 5 public static final int MOUSE_ BUTTON_1 = 6 public static final int MOUSE_ BUTTON_2 = 7 public static final int MOUSE_ BUTTON_3 = 8 private static final int NUM_ MOUSE_ CODES = 9 / ps códigos de teclas são definidos em java awt Key Event a maiortia dos códigos com excessão de alguns raros como alt graph são menores que 600 / private static final int NUM_ KEY_ CODES = 600 private Game Action[] key Actions = new Game Action[ NUM_ KEY_ CODES ] private Game Action[] mouse Actions = new Game Action[ NUM_ MOUSE_ CODES ] private Point mouse Location private Point center Location private Component comp private Robot robot private boolean is Recentering / Cria um novo Input Manager que ouve as entradas de um componente específico / public Input Manager Component comp this comp = comp mouse Location = new Point center Location = new Point registra os ouvintes de tecla e do mouse comp add Key Listener this comp add Mouse Listener this comp add Mouse Motion Listener this comp add Mouse Wheel Listener this / permite a entrada da tecla TAB e outras teclas normalmente usadas pelo focus traversal / comp set Focus Traversal Keys Enabled false / Configura o cursor no componente do Input Manager / public void set Cursor Cursor cursor comp set Cursor cursor / Configura quando o modo relativo do mous está ligado ou não Para o modo relativo do mouse o cursor fica trancado no centro da tela e somente a mudança no movimento do mouse é medida No modo normal o mouse fica livre para mover pela a tela / public void set Relative Mouse Mode boolean mode if mode == is Relative Mouse Mode return if mode try robot = new Robot recenter Mouse catch AWT Exception ex não pôde criar um Robot robot = null else robot = null / Retorna se o modo relativo do mouse está ligado ou não / public boolean is Relative Mouse Mode return robot != null / Mapeia uma Game Action para uma tecla específica Os códigos das telas são definidos em java awt Key Event Se a tecla já tiver uma Game Action mapeada a ela a nova Game Action sobrescreve a mesma / public void map To Key Game Action game Action int key Code key Actions[ key Code ] = game Action / Mapeia uma Game Action para uma ação específica do mouse Os códigos do mouse são definidos aqui no Input Manager MOUSE_ MOVE_ LEFT MOUSE_ BUTTON_1 etc Se a ação do mouse já tiver uma Game Action mapeada a ela a nova Game Action sobrescreverá a mesma / public void map To Mouse Game Action game Action int mouse Code mouse Actions[ mouse Code ] = game Action / Limpa todas as teclas mapeadas e ações do mouse para essa Game Action / public void clear Map Game Action game Action for int i = 0 i < key Actions length i++ if key Actions[ i ] == game Action key Actions[ i ] = null for int i = 0 i < mouse Actions length i++ if mouse Actions[ i ] == game Action mouse Actions[ i ] = null game Action reset / Obtém uma List dos nomes das teclas e ações do mouse mapeadas para essa Game Action cada entrada na lista é uma / public List get Maps Game Action game Code Array List< > list = new Array List< > for int i = 0 i < key Actions length i++ if key Actions[ i ] == game Code list add get Key Name i for int i = 0 i < mouse Actions length i++ if mouse Actions[ i ] == game Code list add get Mouse Name i return list / Reseta todas as Game Action então elas ficam em um estado que parece que elas não foram pressionadas / public void reset All Game Actions for int i = 0 i < key Actions length i++ if key Actions[ i ] != null key Actions[ i ] reset for int i = 0 i < mouse Actions length i++ if mouse Actions[ i ] != null mouse Actions[ i ] reset / Obtém o nome de um código de tecla / public static get Key Name int key Code return Key Event get Key Text key Code / Obtém o nome de um código do mouse / public static get Mouse Name int mouse Code switch mouse Code case MOUSE_ MOVE_ LEFT: return Mouse Left case MOUSE_ MOVE_ RIGHT: return Mouse Right case MOUSE_ MOVE_ UP: return Mouse Up case MOUSE_ MOVE_ DOWN: return Mouse Down case MOUSE_ WHEEL_ UP: return Mouse Wheel Up case MOUSE_ WHEEL_ DOWN: return Mouse Wheel Down case MOUSE_ BUTTON_1: return Mouse Button 1 case MOUSE_ BUTTON_2: return Mouse Button 2 case MOUSE_ BUTTON_3: return Mouse Button 3 default: return Unknown mouse code + mouse Code / Obtém a posição x do mouse / public int get Mouse X return mouse Location x / Obtém a posição y do mouse / public int get Mouse Y return mouse Location y / Usa a e Robot para tentar posicionar o mouse no centro da tela <p> Note que o uso da e Robot pode não ser possível em todas as plataformas / private synchronized void recenter Mouse if robot != null && comp is Showing center Location x = comp get Width / 2 center Location y = comp get Height / 2 Swing Utilities convert Point To Screen center Location comp is Recentering = true robot mouse Move center Location x center Location y / Retorna a Game Action associada ao Key Event / private Game Action get Key Action Key Event e int key Code = e get Key Code if key Code < key Actions length return key Actions[ key Code ] else return null / Obtém o código do mouse para o botão especificado no Mouse Event / public static int get Mouse Button Code Mouse Event e switch e get Button case Mouse Event BUTTON1: return MOUSE_ BUTTON_1 case Mouse Event BUTTON2: return MOUSE_ BUTTON_2 case Mouse Event BUTTON3: return MOUSE_ BUTTON_3 default: return -1 / Retorna a Game Action associada ao Mouse Event / private Game Action get Mouse Button Action Mouse Event e int mouse Code = get Mouse Button Code e if mouse Code != -1 return mouse Actions[ mouse Code ] else return null public void key Typed Key Event e dá certeza que a tecla não é processada por mais ninguém e consume public void key Pressed Key Event e Game Action game Action = get Key Action e if game Action != null game Action press dá certeza que a tecla não é processada por mais ninguém e consume public void key Released Key Event e Game Action game Action = get Key Action e if game Action != null game Action release dá certeza que a tecla não é processada por mais ninguém e consume public void mouse Clicked Mouse Event e não faz nada public void mouse Pressed Mouse Event e Game Action game Action = get Mouse Button Action e if game Action != null game Action press public void mouse Released Mouse Event e Game Action game Action = get Mouse Button Action e if game Action != null game Action release public void mouse Entered Mouse Event e mouse Moved e public void mouse Exited Mouse Event e mouse Moved e public void mouse Dragged Mouse Event e mouse Moved e public synchronized void mouse Moved Mouse Event e este evento é para recentralizar o mouse if is Recentering && center Location x == e get X && center Location y == e get Y is Recentering = false else int dx = e get X - mouse Location x int dy = e get Y - mouse Location y mouse Helper MOUSE_ MOVE_ LEFT MOUSE_ MOVE_ RIGHT dx mouse Helper MOUSE_ MOVE_ UP MOUSE_ MOVE_ DOWN dy if is Relative Mouse Mode recenter Mouse mouse Location x = e get X mouse Location y = e get Y public void mouse Wheel Moved Mouse Wheel Event e mouse Helper MOUSE_ WHEEL_ UP MOUSE_ WHEEL_ DOWN e get Wheel Rotation / Calcula e configura a movimentação do mouse / private void mouse Helper int code Neg int code Pos int amount Game Action game Action if amount < 0 game Action = mouse Actions[ code Neg ] else game Action = mouse Actions[ code Pos ] if game Action != null game Action press Math absamount game Action release  / A e Echo Filter é um Sound Filter que emula um éco @see Filtered Sound Stream @author David Buzatto / public Echo Filter extends Sound Filter private short[] delay Buffer private int delay Buffer Pos private float decay / Cria um Echo Filter com o número especificado de atrasos e com a taxa de decaimento <p> O número de atrasos especifica por quanto tempo o éco será ouvido inicialmente Para um éco de 1 segundos com mono som de 44100 Hz use 44100 de atraso <p> O valor de decaimento é o quanto o éco decai a partir da fonte Um valor de deciamento de 5 siginifica que o éco é ouvido com a metada da intensidade do som da fonte / public Echo Filter int num Delay Samples float decay delay Buffer = new short[ num Delay Samples ] this decay = decay / Obtém o tamanho restante em bytes das amostrar que esse filtro pode ecoar antes que o som termine de ser exeuctado Certifica que o som será decaído mens que 1% do volume máximo amplitude / public int get Remaining Size float final Decay = 0 01f derivado de Math powdecay x <= final Decay int num Remaining Buffers = int Math ceil Math log final Decay / Math log decay int buffer Size = delay Buffer length 2 return buffer Size num Remaining Buffers / Limpa o buffer interno de atrasos do Echo Filter / public void reset for int i = 0 i < delay Buffer length i++ delay Buffer[ i ] = 0 delay Buffer Pos = 0 / Filtra as amostras de som apra adicionar o eco As amostras tocadas são adicionadas ao som do buffer de atraso multiplicadas pela taxa de decaimento O resultado é armazenado no buffer de atraso então múltiplos ecos são ouvidos / public void filterbyte[] samples int offset int length for int i = offset i < offset + length i += 2 atualiza a amostra short old Sample = get Sample samples i short new Sample = short old Sample + decay delay Buffer[ delay Buffer Pos ] set Sample samples i new Sample atualiza o buffer de atrasos delay Buffer[ delay Buffer Pos ] = new Sample delay Buffer Pos++ if delay Buffer Pos == delay Buffer length delay Buffer Pos = 0  / A e Filter3d é um Sound Filter que cria um efeito de som 3 D O som é filtrado tomando como base a fonte do ouvinte <p> Idéias possíveis para estender essa e: <ul><li> Varie o som da caixa de som da esquerda para a da direita </ul> @see Filtered Sound Stream @author David Buzatto / public Filter3d extends Sound Filter número de amostrar que alterar enquanto o volume é mudado private static final int NUM_ SHIFTING_ SAMPLES = 500 private Sprite source private Sprite listener private int max Distance private float last Volume / Cria um novo Filter3d com a fonte especificada como um sprite e o ouvinte outro sprite A posição dos Sprites podem ser mudadoas enquanto o filtro está sendo executado <p> O parâmetro de distância máxima é a distância máxima que o som pode ser ouvido / public Filter3d Sprite source Sprite listener int max Distance this source = source this listener = listener this max Distance = max Distance this last Volume = 0 0f / Filtra o som fazendo que fique mais baixo quando a distância aumenta / public void filter byte[] samples int offset int length if source == null || listener == null nada para filtrar retorna return calcula o distância entre o ouvinte e a fonte do som float dx = source get X - listener get X float dy = source get Y - listener get Y float distance = float Math sqrt dx dx + dy dy seta o voume de 0 sem som para 1 float new Volume = max Distance - distance / max Distance if new Volume <= 0 new Volume = 0 seta o volume da amostra int shift = 0 for int i = offset i < offset + length i += 2 float volume = new Volume altera o volume anterior para o próximo if shift < NUM_ SHIFTING_ SAMPLES volume = last Volume + new Volume - last Volume shift / NUM_ SHIFTING_ SAMPLES shift++ altera o volume da amostra short old Sample = get Sample samples i short new Sample = short old Sample volume set Sample samples i new Sample last Volume = new Volume  / A e Filtered Sound Stream é um Filter Input Stream que aplica um Sound Filter ao input stream da camada abaixo @see Sound Filter @author David Buzatto / public Filtered Sound Stream extends Filter Input Stream private static final int REMAINING_ SIZE_ UNKNOWN = -1 private Sound Filter sound Filter private int remaining Size / Cria um novo Filtered Sound Stream com o Input Stream e Sound Filter especificados / public Filtered Sound Stream Input Stream in Sound Filter sound Filter super in this sound Filter = sound Filter remaining Size = REMAINING_ SIZE_ UNKNOWN / Sobrescreve o método read de Filter Input Stream para aplicar o filtro nos bytes lidos / public int read byte[] samples int offset int length throws IO Exception lê e filtra a amostra de som no stream int bytes Read = super read samples offset length if bytes Read > 0 sound Filter filter samples offset bytes Read return bytes Read / se não há bytes sobrando no stream de som verifica se o filtro contém bytes restantes écos / if remaining Size == REMAINING_ SIZE_ UNKNOWN remaining Size = sound Filter get Remaining Size arredonda para baixo para o próximo múltiplo mais próximo de 4 normalmente o tamanho do frame remaining Size = remaining Size / 4 4 if remaining Size > 0 length = Math min length remaining Size limpar o buffer for int i = offset i < offset + length i++ samples[ i ] = 0 filtra sound Filter filter samples offset length remaining Size -= length retorna return length else fim do stream return -1  / A e Filter Sequence é um Sound Filter que combina vários Sound Filters em um só @see Filtered Sound Stream @author David Buzatto / public Filter Sequence extends Sound Filter private Sound Filter[] filters / Cria um novo Filter Sequence usando um array de Sound Filters As amostras executam sobre cada Sound Filet na ordem do array / public Filter Sequence Sound Filter[] filters this filters = filters / Retorna a quantidade restante do todos os Sound Filters nesse Filter Sequence / public int get Remaining Size int max = 0 for int i = 0 i < filters length i++ max = Math max max filters[ i ] get Remaining Size return max / Reseta cada Sound Filter nesse Filter Sequence / public void reset for int i = 0 i < filters length i++ filters[ i ] reset / Filtra o som de cada Sound Filter desse Filter Sequence / public void filter byte[] samples int offset int length for int i = 0 i < filters length i++ filters[ i ] filter samples offset length  / A e Midi Player é responsável por reproduzir arquivos mid @author David Buzatto / public Midi Player implements Meta Event Listener Evento meta Midi public static final int END_ OF_ TRACK_ MESSAGE = 47 private Sequencer sequencer private boolean loop private boolean paused public boolean executando = false / Cria um novo Midi Player / public Midi Player try sequencer = Midi System get Sequencer sequencer open sequencer add Meta Event Listener this catch Midi Unavailable Exception ex sequencer = null / Carrega a seqüência do sistema de arquivos Retorna null se um erro ocorrer / public Sequence get Sequence name filename = /recursos/sons/ + name try return Midi System get Sequence get Class get Resource filename catch Invalid Midi Data Exception ex ex print Stack Trace return null catch IO Exception ex ex print Stack Trace return null / Executa uma seqüência realizando um loop opcionalmente Esse método retorna imediatamente A seqüência não é executada se não for válida / public void play Sequence sequence boolean loop if sequencer != null && sequence != null try sequencer set Sequence sequence sequencer start this loop = loop catch Invalid Midi Data Exception ex ex print Stack Trace / Esse método é chamado pelo sistema de som onde o evento meta ocorre Nesse caso quando o meta evento end-of-track é recebido a seqüência é reiniciada se o loop estiver ligado / public void meta Meta Message event if event get Type == END_ OF_ TRACK_ MESSAGE if sequencer != null && sequencer is Open && loop sequencer start executando = false / Para o seqüenciador e reinicia sua posição para 0 / public void stop if sequencer != null && sequencer is Open sequencer stop sequencer set Microsecond Position 0 / Fechao o seqüenciador / public void close if sequencer != null && sequencer is Open sequencer close / Obtém o seqüenciador / public Sequencer get Sequencer return sequencer / Configura o estado de pausa A música pode não parar imediatamente / public void set Paused boolean paused if this paused != paused && sequencer != null this paused = paused if paused sequencer stop else sequencer start / Returna se está pausado / public boolean is Paused return paused  / A e Sound é um container para amostras de som As amostras de som são de formato desconhecido e armazenadas como um array de bytes @author David Buzatto / public Sound private byte[] samples / Cria um novo objeto Sound com o array de bytes especificado O array não é copiado / public Sound byte[] samples this samples = samples / Retorna esse objeto Sound como um array de byres / public byte[] get Samples return samples  / Classe abstrata desenvolvida para filtrar amostras de som Como os Sound Filters podem usar buferização interna de amostras um novo Sound Filter deve ser criado para cada som executado Entretanto Sound Filters podem ser reusados após serem finalizados chamando o método reset Assume-se que todas as amostrars são de 16-bit sinalizadas e no formato little-endian @see Filtered Sound Stream @author David Buzatto / public abstract Sound Filter / Reseta esse Sound Filter Não faz nada por padrão / public void reset não faz nada / Obtém o tamanho restante em bytes que esre filtro executa após o som ser finalizado that this filter Um exemplo pode ser um éco que executa mais que o seu som original Esse método retorna 0 por padrão / public int get Remaining Size return 0 / Filtra um array de amostrar As amostras devem ser de 16-bit sinalizadas e no formato little-endian / public void filter byte[] samples filter samples 0 samples length / Filtra um array de amostras As amostras devem ser de 16-bit sinalizadas e no formato little-endian Esse método deve ser implementado pelas sub es Atenção o offset e o tamanho referen-se ao número de bytes e não amostras / public abstract void filter byte[] samples int offset int length / Método de conveniência para obter uma amostra de 16-bit de um array de bytes As amostras devem ser de 16-bit sinalizadas e no formato little-endian / public static short get Sample byte[] buffer int position return short buffer[ position + 1 ] & 0xff << 8 | buffer[ position ] & 0xff / Método de conveniência para configurar uma amostra de 16-bit em um array de bytes As amostras devem ser de 16-bit sinalizadas e no formato little-endian / public static void set Sample byte[] buffer int position short sample buffer[ position ] = byte sample & 0xff buffer[ position + 1 ] = byte sample >> 8 & 0xff  / A e Sound Manager gerencia a execução dos sons A Sound Manager é um Thread Pool onde cada thread executa um som por vez Isso permite que o Sound Manager facilmente limite o tamanho de sons simultâneos que são executados @author David Buzatto / public Sound Manager extends Thread Pool private Audio Format playback Format private Thread Local< Source Data Line > local Line private Thread Local< byte[] > local Buffer private Object paused Lock private boolean paused / Cria um novo Sound Manager usando o número máqimo de sons executados simultaneamente / public Sound Manager Audio Format playback Format this playback Format get Max Simultaneous Sounds playback Format / Cria um novo Sound Manager usando o número máqimo de sons executados simultaneamente / public Sound Manager Audio Format playback Format int max Simultaneous Sounds super max Simultaneous Sounds this playback Format = playback Format local Line = new Thread Local< Source Data Line > local Buffer = new Thread Local< byte[] > paused Lock = new Object notifica o thread pool que está tudo ok para iniciar synchronized this notify All / Obtém o número máximo de sons que pode ser executados / public static int get Max Simultaneous Sounds Audio Format playback Format Data Line Info line Info = new Data Line Info Source Data Line playback Format Mixer mixer = Audio System get Mixer null int lines = mixer get Max Lines line Info if lines == Audio System NOT_ SPECIFIED return 16 presume que seja 16 return mixer get Max Lines line Info / Faz limpesa antes de fechar / protected void clean Up sinal para parar set Paused false fecha o mixer para qualquer som que está executando Mixer mixer = Audio System get Mixer null if mixer is Open mixer close public void close clean Up super close public void join clean Up super join / Configura o estado de pausa Os sons podem não pausar imediatamente / public void set Paused boolean paused if this paused != paused synchronized paused Lock this paused = paused if !paused reinicia os sons paused Lock notify All / Retorna o estado de pausa / public boolean is Paused return paused / Carrega um som do sistema de arquivos Retorna null caso ocorra algum erro / public Sound get Sound name return get Sound get Audio Input Stream name / Carreha um dom de um Audio Input Stream / public Sound get Sound Audio Input Stream audio Stream if audio Stream == null return null obtém o número de bytes a ler int length = int audio Stream get Frame Length audio Stream get Format get Frame Size lê todo o stream byte[] samples = new byte[ length ] Data Input Stream is = new Data Input Stream audio Stream try is read Fully samples catch IO Exception ex ex print Stack Trace returna os samples return new Soundsamples / Cria um Audio Input Stream usando um arquivo / public Audio Input Stream get Audio Input Stream name filename = /recursos/sons/ + name try abre o arquivo Audio Input Stream source = Audio System get Audio Input Stream get Class get Resource filename converte para o formato de execução return Audio System get Audio Input Stream playback Format source catch Unsupported Audio File Exception ex ex print Stack Trace catch IO Exception ex ex print Stack Trace catch Illegal Argument Exception ex ex print Stack Trace return null / Executa um som Esse método retorna imediatamente / public Input Stream play Sound sound return play sound null false / Executa um som com um Sound Filter especificado Esse método retorna imediatamente / public Input Stream play Sound sound Sound Filter filter boolean loop Input Stream is if sound != null if loop is = new Looping Byte Input Stream sound get Samples else is = new Byte Array Input Stream sound get Samples return play is filter return null / Executa um som de um Input Stream Esse método retorna imediatamente / public Input Stream play Input Stream is return play is null / Executa um som de um Input Stream com um filtro opcional Esse método retorna imediatamente / public Input Stream play Input Stream is Sound Filter filter if is != null if filter != null is = new Filtered Sound Stream is filter run Task new Sound Player is return is / Sinaliza a Pooled Thread que iniciou Cria a linha e o buffer da thread / protected void thread Started aguarda o construtor do Sound Manager terminar synchronized this try wait catch Interrupted Exception ex use um pequeno buffer de 100ms 1/10th seg para os filtros que mudam em tempo real int buffer Size = playback Format get Frame Size Math round playback Format get Sample Rate / 10 cria abre e inicia a linha Source Data Line line Data Line Info line Info = new Data Line Info Source Data Line playback Format try line = Source Data Line Audio System get Line line Info line open playback Format buffer Size catch Line Unavailable Exception ex a linha não está disponível sinaliza para finalizar a thread Thread current Thread interrupt return line start cria o buffer byte[] buffer = new byte[ buffer Size ] seta a thread como local local Line set line local Buffer set buffer / Sinaliza que a Pooled Thread parou Drena e fecha a linha da thread / protected void thread Stopped Source Data Line line = local Line get if line != null line drain line close / A e Sound Plauer é uma tareda para as Pooled Threads executarem Este recebe uma linha da thread e um buffer de bytes das variáveis da Thread Local e executa o som de um Input Stream <p> Essa e só funciona quando chamada de dentro de uma Pooled Thread / protected Sound Player implements Runnable private Input Stream source public Sound Player Input Stream source this source = source public void run obtém a linha e o buffer do Thread Locals Source Data Line line = Source Data Line local Line get byte[] buffer = byte[] local Buffer get if line == null || buffer == null linha não disponível return copia os dados para a linha try int num Bytes Read = 0 while num Bytes Read != -1 se pausado aguarda até sair da pausa synchronized paused Lock if paused try paused Lock wait catch Interrupted Exception ex return copia os dados num Bytes Read = source read buffer 0 buffer length if num Bytes Read != -1 line write buffer 0 num Bytes Read catch IO Exception ex ex print Stack Trace  / O Looping Byte Input Stream é um Byte Array Input Stream que entra em loop infinito O loop para quando o método close é chamado <p> Idéias possíveis para estender a e:<ul> <li> Adicionar uma opção para executar um número definido de vezes </ul> @author David Buzatto / public Looping Byte Input Stream extends Byte Array Input Stream private boolean closed / Cria um novo Looping Byte Input Stream com o array de bytes especificado O array não é copiado / public Looping Byte Input Stream byte[] buffer super buffer closed = false / Lê <code>length</code> bytes do array Se o fim do array é atingido a leitura inicia novamente do começo do array Returna -1 se o array foi fechado / public int read byte[] buffer int offset int length if closed return -1 int total Bytes Read = 0 while total Bytes Read < length int num Bytes Read = super read buffer offset + total Bytes Read length - total Bytes Read if num Bytes Read > 0 total Bytes Read += num Bytes Read else reset return total Bytes Read / Fecha o stream Chamadas futuras a read retornarão 1 / public void close throws IO Exception super close closed = true  / A e Resource Manager carrega e gerencia os pedaços tiles de Images e as Sprites hospedeiras usadas no jogo As sprites do Jogo são clonadas a partir das Sprites hospedeiras @author David Buzatto / public Resource Manager private Array List< Image > tiles private int current Map private Graphics Configuration gc sprites hospedeiras usadas na clonagem private Sprite player Sprite private Sprite mushroom Sprite private Sprite coin Sprite private Sprite fire Flower Sprite private Sprite one Up Sprite private Sprite goal Sprite private Sprite goomba Sprite private Sprite fly Goomba Sprite private Sprite green Koopa Sprite private Sprite red Koopa Sprite private Sprite blue Koopa Sprite private Sprite yellow Koopa Sprite private Sprite bomb Sprite private Sprite bullet Sprite private Sprite bat Sprite private Sprite turtle Sprite private Sprite mummy Turtle Sprite private Sprite blue Dragon Sprite / Cria um novo Resource Manager com o Graphics Configuration especificado e a letra do último tile / public Resource Manager Graphics Configuration gc char max Tile Letter this gc = gc load Tile Images max Tile Letter load Creature Sprites load Power Up Sprites / Obtem uma imagem do diretório /recursos/imagens/ / public Image load Image name filename = /recursos/imagens/ + name return new Image Icon get Class get Resource filename get Image / Cria uma imagem espelhada / public Image get Mirror Image Image image return get Scaled Image image -1 1 / Cria uma imagem rotacionada / public Image get Flipped Image Image image return get Scaled Imageimage 1 -1 / Aplica operação de escala em uma imagem / private Image get Scaled Image Image image float x float y configura a transformação Affine Transform transform = new Affine Transform transform scale x y transform translate x - 1 image get Width null / 2 y - 1 image get Height null / 2 cria uma imagem transparente não translúcida Image new Image = gc create Compatible Image image get Width null image get Height null Transparency BITMASK desenha a imagem transformada Graphics2 D g = Graphics2 D new Image get Graphics g draw Image image transform null g dispose return new Image / Aplica operação de escala esmagando uma figura / private Image get Smashed Image Image image configura a transformação Affine Transform transform = new Affine Transform transform scale 1 0 5 transform translate 0 image get Height null cria uma imagem transparente não translúcida Image new Image = gc create Compatible Image image get Width null image get Height null Transparency BITMASK desenha a imagem transformada Graphics2 D g = Graphics2 D new Image get Graphics g draw Image image transform null g dispose return new Image / Carrega o próximo mapa / public Tile Map load Next Map Tile Map map = null while map == null current Map++ try map = load Map map + current Map + txt catch IO Exception ex if current Map == 1 nenhum para carregado return null current Map = 0 map = null return map / Recarrega o mapa atual / public Tile Map reload Map try return load Map map + current Map + txt catch IO Exception ex ex print Stack Trace return null / Carrega um mapa do diretório /recursos/mapas/ / private Tile Map load Map name throws IO Exception filename = /recursos/mapas/ + name Array List< > lines = new Array List< > int width = 0 int height = 0 Buffered Reader reader try reader = new Buffered Reader new Input Stream Reader get Class get Resource As Stream filename while true line = reader read Line sem mais linhas para ler if line == null reader close break adiciona toda linha menos os comentários if !line starts With # lines add line width = Math max width line length parseia as linhas para criar uma Tile Engine height = lines size Tile Map new Map = new Tile Map width height for int y = 0 y < height y++ line = lines get y for int x = 0 x < line length x++ char ch = line char At x verifica o tile que o caracter atual representa int tile = ch - A if tile >= 0 && tile < tiles size new Map set Tile x y Image tiles gettile checa se o caracter representa umaa sprite else if ch == o add Sprite new Map coin Sprite x y else if ch == ! add Sprite new Map mushroom Sprite x y else if ch == f add Sprite new Map fire Flower Sprite x y else if ch == u add Sprite new Map one Up Sprite x y else if ch == add Sprite new Map goal Sprite x y else if ch == 1 add Sprite new Map goomba Sprite x y else if ch == 2 add Sprite new Map fly Goomba Sprite x y else if ch == 3 add Sprite new Map green Koopa Sprite x y else if ch == 4 add Sprite new Map red Koopa Sprite x y else if ch == 5 add Sprite new Map blue Koopa Sprite x y else if ch == 6 add Sprite new Map yellow Koopa Sprite x y else if ch == 7 add Sprite new Map bomb Sprite x y else if ch == 8 add Sprite new Map bullet Sprite x y else if ch == 9 add Sprite new Map bat Sprite x y else if ch == @ add Sprite new Map turtle Sprite x y else if ch == $ add Sprite new Map mummy Turtle Sprite x y else if ch == % add Sprite new Map blue Dragon Sprite x y adiciona o jogador no mapa Sprite player = Sprite player Sprite clone player set X Tile Map Renderer tiles To Pixels 3 player set Y 0 new Map set Player player return new Map catch File Not Found Exception ex ex print Stack Trace return null / Adiciona uma Sprite em uma mapa / private void add Sprite Tile Map map Sprite host Sprite int tile X int tile Y if host Sprite != null clona a sprite usando a hospedeira Sprite sprite = Sprite host Sprite clone centraliza a sprite sprite set X Tile Map Renderer tiles To Pixels tile X + Tile Map Renderer tiles To Pixels 1 - sprite get Width / 2 alinha a sprite no chão sprite set Y Tile Map Renderer tiles To Pixels tile Y + 1 - sprite get Height adiciona no mapa map add Spritesprite / ----------------------------------------------------------- Código para carga de sprites e imagens ---------------------------------------------------------/ / Carrega as imagens dos tiles usando um caracter máximo / public void load Tile Images char max tiles = new Array List< Image > char ch = A while ch <= max name = tile_ + ch + png tiles add load Image name ch++ / Carrega as sprites das criaturas / public void load Creature Sprites o número de linhas indica a quantidade de estados da sprite Image[][] imagens Mario = new Image[ 2 ][] Image[][] imagens Mario Andando = new Image[ 2 ][] Image[][] imagens Mario Pulando = new Image[ 2 ][] Image[][] imagens Mario Morrendo = new Image[ 2 ][] Image[][] imagens Mario Abaixado = new Image[ 2 ][] Image[][] imagens Fly Goomba = new Image[ 4 ][] Image[][] imagens Goomba = new Image[ 4 ][] Image[][] imagens Green Koopa = new Image[ 4 ][] Image[][] imagens Red Koopa = new Image[ 4 ][] Image[][] imagens Blue Koopa = new Image[ 4 ][] Image[][] imagens Yellow Koopa = new Image[ 4 ][] Image[][] imagens Bomb = new Image[ 4 ][] Image[][] imagens Bullet = new Image[ 4 ][] Image[][] imagens Bat = new Image[ 4 ][] Image[][] imagens Turtle = new Image[ 4 ][] Image[][] imagens Mummy Turtle = new Image[ 4 ][] Image[][] imagens Blue Dragon = new Image[ 4 ][] carrega imagens viradas à esquerda para o sonic imagens Mario[ 0 ] = new Image[] load Image mario1 png imagens Mario Andando[ 0 ] = new Image[] load Image mario1 png load Image mario2 png imagens Mario Pulando[ 0 ] = new Image[] load Image mario Jump1 png load Image mario Jump2 png imagens Mario Morrendo[ 0 ] = new Image[] load Image mario Dying1 png load Image mario Dying2 png imagens Mario Abaixado[ 0 ] = new Image[] load Image mario Down1 png carrega imagens viradas à esquerda para o fly Goomba imagens Fly Goomba[ 0 ] = new Image[] load Image fly Goomba1 png load Image fly Goomba2 png carrega imagens viradas à esquerda para o goomba imagens Goomba[ 0 ] = new Image[] load Image goomba1 png load Image goomba2 png carrega imagens viradas à esquerda para o green koopa imagens Green Koopa[ 0 ] = new Image[] load Image green Koopa1 png load Image green Koopa2 png carrega imagens viradas à esquerda para o red koopa imagens Red Koopa[ 0 ] = new Image[] load Image red Koopa1 png load Image red Koopa2 png carrega imagens viradas à esquerda para o blue koopa imagens Blue Koopa[ 0 ] = new Image[] load Image blue Koopa1 png load Image blue Koopa2 png carrega imagens viradas à esquerda para o yellow koopa imagens Yellow Koopa[ 0 ] = new Image[] load Image yellow Koopa1 png load Image yellow Koopa2 png carrega imagens viradas à esquerda para o bomb imagens Bomb[ 0 ] = new Image[] load Image bomb1 png load Image bomb2 png carrega imagens viradas à esquerda para o bullet imagens Bullet[ 0 ] = new Image[] load Image bullet1 png carrega imagens viradas à esquerda para o bat imagens Bat[ 0 ] = new Image[] load Image bat1 png load Image bat2 png carrega imagens viradas à esquerda para o turtle imagens Turtle[ 0 ] = new Image[] load Image turtle1 png load Image turtle2 png carrega imagens viradas à esquerda para o mummy turtle imagens Mummy Turtle[ 0 ] = new Image[] load Image mummy Turtle1 png load Image mummy Turtle2 png carrega imagens viradas à esquerda para o blue dragon imagens Blue Dragon[ 0 ] = new Image[] load Image blue Dragon1 png load Image blue Dragon2 png para cada estado cria um novo array com o tamanho da primeira linha imagens Mario[ 1 ] = new Image[ imagens Mario[ 0 ] length ] imagens Mario Andando[ 1 ] = new Image[ imagens Mario Andando[ 0 ] length ] imagens Mario Pulando[ 1 ] = new Image[ imagens Mario Pulando[ 0 ] length ] imagens Mario Morrendo[ 1 ] = new Image[ imagens Mario Morrendo[ 0 ] length ] imagens Mario Abaixado[ 1 ] = new Image[ imagens Mario Abaixado[ 0 ] length ] imagens Fly Goomba[ 1 ] = new Image[ imagens Fly Goomba[ 0 ] length ] imagens Fly Goomba[ 2 ] = new Image[ imagens Fly Goomba[ 0 ] length ] imagens Fly Goomba[ 3 ] = new Image[ imagens Fly Goomba[ 0 ] length ] imagens Goomba[ 1 ] = new Image[ imagens Goomba[ 0 ] length ] imagens Goomba[ 2 ] = new Image[ imagens Goomba[ 0 ] length ] imagens Goomba[ 3 ] = new Image[ imagens Goomba[ 0 ] length ] imagens Green Koopa[ 1 ] = new Image[ imagens Green Koopa[ 0 ] length ] imagens Green Koopa[ 2 ] = new Image[ imagens Green Koopa[ 0 ] length ] imagens Green Koopa[ 3 ] = new Image[ imagens Green Koopa[ 0 ] length ] imagens Red Koopa[ 1 ] = new Image[ imagens Red Koopa[ 0 ] length ] imagens Red Koopa[ 2 ] = new Image[ imagens Red Koopa[ 0 ] length ] imagens Red Koopa[ 3 ] = new Image[ imagens Red Koopa[ 0 ] length ] imagens Blue Koopa[ 1 ] = new Image[ imagens Blue Koopa[ 0 ] length ] imagens Blue Koopa[ 2 ] = new Image[ imagens Blue Koopa[ 0 ] length ] imagens Blue Koopa[ 3 ] = new Image[ imagens Blue Koopa[ 0 ] length ] imagens Yellow Koopa[ 1 ] = new Image[ imagens Yellow Koopa[ 0 ] length ] imagens Yellow Koopa[ 2 ] = new Image[ imagens Yellow Koopa[ 0 ] length ] imagens Yellow Koopa[ 3 ] = new Image[ imagens Yellow Koopa[ 0 ] length ] imagens Bomb[ 1 ] = new Image[ imagens Bomb[ 0 ] length ] imagens Bomb[ 2 ] = new Image[ imagens Bomb[ 0 ] length ] imagens Bomb[ 3 ] = new Image[ imagens Bomb[ 0 ] length ] imagens Bullet[ 1 ] = new Image[ imagens Bullet[ 0 ] length ] imagens Bullet[ 2 ] = new Image[ imagens Bullet[ 0 ] length ] imagens Bullet[ 3 ] = new Image[ imagens Bullet[ 0 ] length ] imagens Bat[ 1 ] = new Image[ imagens Bat[ 0 ] length ] imagens Bat[ 2 ] = new Image[ imagens Bat[ 0 ] length ] imagens Bat[ 3 ] = new Image[ imagens Bat[ 0 ] length ] imagens Turtle[ 1 ] = new Image[ imagens Turtle[ 0 ] length ] imagens Turtle[ 2 ] = new Image[ imagens Turtle[ 0 ] length ] imagens Turtle[ 3 ] = new Image[ imagens Turtle[ 0 ] length ] imagens Mummy Turtle[ 1 ] = new Image[ imagens Mummy Turtle[ 0 ] length ] imagens Mummy Turtle[ 2 ] = new Image[ imagens Mummy Turtle[ 0 ] length ] imagens Mummy Turtle[ 3 ] = new Image[ imagens Mummy Turtle[ 0 ] length ] imagens Blue Dragon[ 1 ] = new Image[ imagens Blue Dragon[ 0 ] length ] imagens Blue Dragon[ 2 ] = new Image[ imagens Blue Dragon[ 0 ] length ] imagens Blue Dragon[ 3 ] = new Image[ imagens Blue Dragon[ 0 ] length ] para cada coluna do array configura as imagens correpondentes aos estados for int i = 0 i < imagens Mario[ 0 ] length i++ imagens viradas à direita imagens Mario[ 1 ][ i ] = get Mirror Image imagens Mario[ 0 ][ i ] for int i = 0 i < imagens Mario Andando[ 0 ] length i++ imagens viradas à direita imagens Mario Andando[ 1 ][ i ] = get Mirror Image imagens Mario Andando[ 0 ][ i ] for int i = 0 i < imagens Mario Pulando[ 0 ] length i++ imagens viradas à direita imagens Mario Pulando[ 1 ][ i ] = get Mirror Image imagens Mario Pulando[ 0 ][ i ] for int i = 0 i < imagens Mario Andando[ 0 ] length i++ imagens viradas à direita imagens Mario Andando[ 1 ][ i ] = get Mirror Image imagens Mario Andando[ 0 ][ i ] for int i = 0 i < imagens Mario Morrendo[ 0 ] length i++ imagens viradas à direita imagens Mario Morrendo[ 1 ][ i ] = get Mirror Image imagens Mario Morrendo[ 0 ][ i ] for int i = 0 i < imagens Mario Abaixado[ 0 ] length i++ imagens viradas à direita imagens Mario Abaixado[ 1 ][ i ] = get Mirror Image imagens Mario Abaixado[ 0 ][ i ] for int i = 0 i < imagens Fly Goomba[ 0 ] length i++ imagens viradas à direita imagens Fly Goomba[ 1 ][ i ] = get Mirror Image imagens Fly Goomba[ 0 ][ i ] imagens viradas à esquerda mortas imagens Fly Goomba[ 2 ][ i ] = get Smashed Image imagens Fly Goomba[ 0 ][ i ] imagens viradas à direita mortas imagens Fly Goomba[ 3 ][ i ] = get Smashed Image imagens Fly Goomba[ 1 ][ i ] for int i = 0 i < imagens Goomba[ 0 ] length i++ imagens viradas à direita imagens Goomba[ 1 ][ i ] = get Mirror Image imagens Goomba[ 0 ][ i ] imagens viradas à esquerda mortas imagens Goomba[ 2 ][ i ] = get Smashed Image imagens Goomba[ 0 ][ i ] imagens viradas à direita mortas imagens Goomba[ 3 ][ i ] = get Smashed Image imagens Goomba[ 1 ][ i ] for int i = 0 i < imagens Green Koopa[ 0 ] length i++ imagens viradas à direita imagens Green Koopa[ 1 ][ i ] = get Mirror Image imagens Green Koopa[ 0 ][ i ] imagens viradas à esquerda mortas imagens Green Koopa[ 2 ][ i ] = get Smashed Image imagens Green Koopa[ 0 ][ i ] imagens viradas à direita mortas imagens Green Koopa[ 3 ][ i ] = get Smashed Image imagens Green Koopa[ 1 ][ i ] for int i = 0 i < imagens Red Koopa[ 0 ] length i++ imagens viradas à direita imagens Red Koopa[ 1 ][ i ] = get Mirror Image imagens Red Koopa[ 0 ][ i ] imagens viradas à esquerda mortas imagens Red Koopa[ 2 ][ i ] = get Smashed Image imagens Red Koopa[ 0 ][ i ] imagens viradas à direita mortas imagens Red Koopa[ 3 ][ i ] = get Smashed Image imagens Red Koopa[ 1 ][ i ] for int i = 0 i < imagens Blue Koopa[ 0 ] length i++ imagens viradas à direita imagens Blue Koopa[ 1 ][ i ] = get Mirror Image imagens Blue Koopa[ 0 ][ i ] imagens viradas à esquerda mortas imagens Blue Koopa[ 2 ][ i ] = get Smashed Image imagens Blue Koopa[ 0 ][ i ] imagens viradas à direita mortas imagens Blue Koopa[ 3 ][ i ] = get Smashed Image imagens Blue Koopa[ 1 ][ i ] for int i = 0 i < imagens Yellow Koopa[ 0 ] length i++ imagens viradas à direita imagens Yellow Koopa[ 1 ][ i ] = get Mirror Image imagens Yellow Koopa[ 0 ][ i ] imagens viradas à esquerda mortas imagens Yellow Koopa[ 2 ][ i ] = get Smashed Image imagens Yellow Koopa[ 0 ][ i ] imagens viradas à direita mortas imagens Yellow Koopa[ 3 ][ i ] = get Smashed Image imagens Yellow Koopa[ 1 ][ i ] for int i = 0 i < imagens Bomb[ 0 ] length i++ imagens Bomb viradas à direita imagens Bomb[ 1 ][ i ] = get Mirror Image imagens Bomb[ 0 ][ i ] imagens Bomb viradas à esquerda mortas imagens Bomb[ 2 ][ i ] = get Smashed Image imagens Bomb[ 0 ][ i ] imagens Bomb viradas à direita mortas imagens Bomb[ 3 ][ i ] = get Smashed Image imagens Bomb[ 1 ][ i ] for int i = 0 i < imagens Bullet[ 0 ] length i++ imagens Bullet viradas à direita imagens Bullet[ 1 ][ i ] = get Mirror Image imagens Bullet[ 0 ][ i ] imagens Bullet viradas à esquerda mortas imagens Bullet[ 2 ][ i ] = get Smashed Image imagens Bullet[ 0 ][ i ] imagens Bullet viradas à direita mortas imagens Bullet[ 3 ][ i ] = get Smashed Image imagens Bullet[ 1 ][ i ] for int i = 0 i < imagens Bat[ 0 ] length i++ imagens Bat viradas à direita imagens Bat[ 1 ][ i ] = get Mirror Image imagens Bat[ 0 ][ i ] imagens Bat viradas à esquerda mortas imagens Bat[ 2 ][ i ] = get Smashed Image imagens Bat[ 0 ][ i ] imagens Bat viradas à direita mortas imagens Bat[ 3 ][ i ] = get Smashed Image imagens Bat[ 1 ][ i ] for int i = 0 i < imagens Turtle[ 0 ] length i++ imagens Turtle viradas à direita imagens Turtle[ 1 ][ i ] = get Mirror Image imagens Turtle[ 0 ][ i ] imagens Turtle viradas à esquerda mortas imagens Turtle[ 2 ][ i ] = get Smashed Image imagens Turtle[ 0 ][ i ] imagens Turtle viradas à direita mortas imagens Turtle[ 3 ][ i ] = get Smashed Image imagens Turtle[ 1 ][ i ] for int i = 0 i < imagens Mummy Turtle[ 0 ] length i++ imagens Mummy Turtle viradas à direita imagens Mummy Turtle[ 1 ][ i ] = get Mirror Image imagens Mummy Turtle[ 0 ][ i ] imagens Mummy Turtle viradas à esquerda mortas imagens Mummy Turtle[ 2 ][ i ] = get Smashed Image imagens Mummy Turtle[ 0 ][ i ] imagens Mummy Turtle viradas à direita mortas imagens Mummy Turtle[ 3 ][ i ] = get Smashed Image imagens Mummy Turtle[ 1 ][ i ] for int i = 0 i < imagens Blue Dragon[ 0 ] length i++ imagens Blue Dragon viradas à direita imagens Blue Dragon[ 1 ][ i ] = get Mirror Image imagens Blue Dragon[ 0 ][ i ] imagens Blue Dragon viradas à esquerda mortas imagens Blue Dragon[ 2 ][ i ] = get Smashed Image imagens Blue Dragon[ 0 ][ i ] imagens Blue Dragon viradas à direita mortas imagens Blue Dragon[ 3 ][ i ] = get Smashed Image imagens Blue Dragon[ 1 ][ i ] cria as animações das criaturas baseado na quantidade de estados Animation[] player Anim = new Animation[ imagens Mario length ] Animation[] player Anim Andando = new Animation[ imagens Mario Andando length ] Animation[] player Anim Pulando = new Animation[ imagens Mario Pulando length ] Animation[] player Anim Morrendo = new Animation[ imagens Mario Morrendo length ] Animation[] player Anim Abaixado = new Animation[ imagens Mario Abaixado length ] Animation[] fly Goomba Anim = new Animation[ imagens Fly Goomba length ] Animation[] goomba Anim = new Animation[ imagens Goomba length ] Animation[] green Koopa Anim = new Animation[ imagens Green Koopa length ] Animation[] red Koopa Anim = new Animation[ imagens Red Koopa length ] Animation[] blue Koopa Anim = new Animation[ imagens Blue Koopa length ] Animation[] yellow Koopa Anim = new Animation[ imagens Yellow Koopa length ] Animation[] bomb Anim = new Animation[ imagens Bomb length ] Animation[] bullet Anim = new Animation[ imagens Bullet length ] Animation[] bat Anim = new Animation[ imagens Bat length ] Animation[] turtle Anim = new Animation[ imagens Turtle length ] Animation[] mummy Turtle Anim = new Animation[ imagens Mummy Turtle length ] Animation[] blue Dragon Anim = new Animation[ imagens Blue Dragon length ] itera pela quantidade de estados criando uma animação para cada um deles for int i = 0 i < player Anim length i++ player Anim[ i ] = create Player Anim imagens Mario[ i ][ 0 ] for int i = 0 i < player Anim Andando length i++ player Anim Andando[ i ] = create Player Anim Andando imagens Mario Andando[ i ][ 0 ] imagens Mario Andando[ i ][ 1 ] for int i = 0 i < player Anim Pulando length i++ player Anim Pulando[ i ] = create Player Anim Pulando imagens Mario Pulando[ i ][ 0 ] imagens Mario Pulando[ i ][ 1 ] for int i = 0 i < player Anim Morrendo length i++ player Anim Morrendo[ i ] = create Player Anim Morrendo imagens Mario Morrendo[ i ][ 0 ] imagens Mario Morrendo[ i ][ 1 ] for int i = 0 i < player Anim Abaixado length i++ player Anim Abaixado[ i ] = create Player Anim Abaixado imagens Mario Abaixado[ i ][ 0 ] for int i = 0 i < fly Goomba Anim length i++ fly Goomba Anim[ i ] = create Fly Goomba Anim imagens Fly Goomba[ i ][ 0 ] imagens Fly Goomba[ i ][ 1 ] for int i = 0 i < goomba Anim length i++ goomba Anim[ i ] = create Goomba Anim imagens Goomba[ i ][ 0 ] imagens Goomba[ i ][ 1 ] for int i = 0 i < green Koopa Anim length i++ green Koopa Anim[ i ] = create Green Koopa Anim imagens Green Koopa[ i ][ 0 ] imagens Green Koopa[ i ][ 1 ] for int i = 0 i < red Koopa Anim length i++ red Koopa Anim[ i ] = create Red Koopa Anim imagens Red Koopa[ i ][ 0 ] imagens Red Koopa[ i ][ 1 ] for int i = 0 i < blue Koopa Anim length i++ blue Koopa Anim[ i ] = create Blue Koopa Anim imagens Blue Koopa[ i ][ 0 ] imagens Blue Koopa[ i ][ 1 ] for int i = 0 i < yellow Koopa Anim length i++ yellow Koopa Anim[ i ] = create Yellow Koopa Anim imagens Yellow Koopa[ i ][ 0 ] imagens Yellow Koopa[ i ][ 1 ] for int i = 0 i < bomb Anim length i++ bomb Anim[ i ] = create Bomb Anim imagens Bomb[ i ][ 0 ] imagens Bomb[ i ][ 1 ] for int i = 0 i < bullet Anim length i++ bullet Anim[ i ] = create Bullet Anim imagens Bullet[ i ][ 0 ] for int i = 0 i < bat Anim length i++ bat Anim[ i ] = create Bat Anim imagens Bat[ i ][ 0 ] imagens Bat[ i ][ 1 ] for int i = 0 i < turtle Anim length i++ turtle Anim[ i ] = create Bat Anim imagens Turtle[ i ][ 0 ] imagens Turtle[ i ][ 1 ] for int i = 0 i < mummy Turtle Anim length i++ mummy Turtle Anim[ i ] = create Bat Anim imagens Mummy Turtle[ i ][ 0 ] imagens Mummy Turtle[ i ][ 1 ] for int i = 0 i < blue Dragon Anim length i++ blue Dragon Anim[ i ] = create Bat Anim imagens Blue Dragon[ i ][ 0 ] imagens Blue Dragon[ i ][ 1 ] cria as sprites das criaturas usando as animações criadas player Sprite = new Player player Anim[ 0 ] player Anim[ 1 ] player Anim Morrendo[ 0 ] player Anim Morrendo[ 1 ] player Anim Andando[ 0 ] player Anim Andando[ 1 ] player Anim Pulando[ 0 ] player Anim Pulando[ 1 ] player Anim Abaixado[ 0 ] player Anim Abaixado[ 1 ] fly Goomba Sprite = new Fly Goomba fly Goomba Anim[ 0 ] fly Goomba Anim[ 1 ] fly Goomba Anim[ 2 ] fly Goomba Anim[ 3 ] goomba Sprite = new Goomba goomba Anim[ 0 ] goomba Anim[ 1 ] goomba Anim[ 2 ] goomba Anim[ 3 ] green Koopa Sprite = new Green Koopa green Koopa Anim[ 0 ] green Koopa Anim[ 1 ] green Koopa Anim[ 2 ] green Koopa Anim[ 3 ] red Koopa Sprite = new Red Koopa red Koopa Anim[ 0 ] red Koopa Anim[ 1 ] red Koopa Anim[ 2 ] red Koopa Anim[ 3 ] blue Koopa Sprite = new Blue Koopa blue Koopa Anim[ 0 ] blue Koopa Anim[ 1 ] blue Koopa Anim[ 2 ] blue Koopa Anim[ 3 ] yellow Koopa Sprite = new Yellow Koopa yellow Koopa Anim[ 0 ] yellow Koopa Anim[ 1 ] yellow Koopa Anim[ 2 ] yellow Koopa Anim[ 3 ] bomb Sprite = new Bomb bomb Anim[ 0 ] bomb Anim[ 1 ] bomb Anim[ 2 ] bomb Anim[ 3 ] bullet Sprite = new Bullet bullet Anim[ 0 ] bullet Anim[ 1 ] bullet Anim[ 2 ] bullet Anim[ 3 ] bat Sprite = new Bat bat Anim[ 0 ] bat Anim[ 1 ] bat Anim[ 2 ] bat Anim[ 3 ] turtle Sprite = new Turtle turtle Anim[ 0 ] turtle Anim[ 1 ] turtle Anim[ 2 ] turtle Anim[ 3 ] mummy Turtle Sprite = new Mummy Turtle mummy Turtle Anim[ 0 ] mummy Turtle Anim[ 1 ] mummy Turtle Anim[ 2 ] mummy Turtle Anim[ 3 ] blue Dragon Sprite = new Blue Dragon blue Dragon Anim[ 0 ] blue Dragon Anim[ 1 ] blue Dragon Anim[ 2 ] blue Dragon Anim[ 3 ] / Cria a animação do jogador / private Animation create Player Anim Image player Animation anim = new Animation anim add Frame player[ 0 ] 250 return anim / Cria a animação do jogador andando / private Animation create Player Anim Andando Image player Animation anim = new Animation anim add Frame player[ 0 ] 100 anim add Frame player[ 1 ] 100 return anim / Cria a animação do jogador pulando / private Animation create Player Anim Pulando Image player Animation anim = new Animation anim add Frame player[ 0 ] 250 anim add Frame player[ 1 ] 5000 return anim / Cria a animação do jogador morrendo / private Animation create Player Anim Morrendo Image player Animation anim = new Animation anim add Frame player[ 0 ] 100 anim add Frame player[ 1 ] 100 return anim / Cria a animação do jogador abaixado / private Animation create Player Anim Abaixado Image player Animation anim = new Animation anim add Frame player[ 0 ] 250 return anim / Cria a animação do Fly Goomba / private Animation create Fly Goomba Anim Image img Animation anim = new Animation anim add Frame img[ 0 ] 200 anim add Frame img[ 1 ] 200 return anim / Cria a animação do Goomba / private Animation create Goomba Anim Image img Animation anim = new Animation anim add Frame img[ 0 ] 200 anim add Frame img[ 1 ] 200 return anim / Cria a animação do Green Koopa / private Animation create Green Koopa Anim Image img Animation anim = new Animation anim add Frame img[ 0 ] 200 anim add Frame img[ 1 ] 200 return anim / Cria a animação do Red Koopa / private Animation create Red Koopa Anim Image img Animation anim = new Animation anim add Frame img[ 0 ] 200 anim add Frame img[ 1 ] 200 return anim / Cria a animação do Blue Koopa / private Animation create Blue Koopa Anim Image img Animation anim = new Animation anim add Frame img[ 0 ] 200 anim add Frame img[ 1 ] 200 return anim / Cria a animação do Yellow Koopa / private Animation create Yellow Koopa Anim Image img Animation anim = new Animation anim add Frame img[ 0 ] 200 anim add Frame img[ 1 ] 200 return anim / Cria a animação do Bomb / private Animation create Bomb Anim Image img Animation anim = new Animation anim add Frame img[ 0 ] 200 anim add Frame img[ 1 ] 200 return anim / Cria a animação do Bullet / private Animation create Bullet Anim Image img Animation anim = new Animation anim add Frame img[ 0 ] 200 return anim / Cria a animação do Bat / private Animation create Bat Anim Image img Animation anim = new Animation anim add Frame img[ 0 ] 200 anim add Frame img[ 1 ] 200 return anim / Cria a animação do Turtle / private Animation create Turtle Anim Image img Animation anim = new Animation anim add Frame img[ 0 ] 200 anim add Frame img[ 1 ] 200 return anim / Cria a animação do Mummy Turtle / private Animation create Mummy Turtle Anim Image img Animation anim = new Animation anim add Frame img[ 0 ] 200 anim add Frame img[ 1 ] 200 return anim / Cria a animação do Blue Dragon / private Animation create Blue Dragon Anim Image img Animation anim = new Animation anim add Frame img[ 0 ] 200 anim add Frame img[ 1 ] 200 return anim / Carrega as sprites de power up / private void load Power Up Sprites cria a sprite de finalização goal Animation anim = new Animation anim add Frame load Image star1 png 20 anim add Frame load Image star2 png 40 anim add Frame load Image star3 png 60 anim add Frame load Image star4 png 80 anim add Frame load Image star5 png 100 anim add Frame load Image star6 png 120 anim add Frame load Image star7 png 150 anim add Frame load Image star6 png 120 anim add Frame load Image star5 png 100 anim add Frame load Image star4 png 80 anim add Frame load Image star3 png 60 anim add Frame load Image star2 png 40 goal Sprite = new Power Up Goal anim cria a sprite de moeda anim = new Animation anim add Frame load Image coin1 png 100 anim add Frame load Image coin2 png 100 anim add Frame load Image coin3 png 100 anim add Frame load Image coin4 png 100 anim add Frame load Image coin5 png 100 coin Sprite = new Power Up Coin anim cria a sprite do cogumelo anim = new Animation anim add Frame load Image mushroom png 150 mushroom Sprite = new Power Up Mushroom anim cria a sprite de vida anim = new Animation anim add Frame load Image one Up png 150 one Up Sprite = new Power Up One Up anim cria a sprite fire flower anim = new Animation anim add Frame load Image fire Flower png 150 fire Flower Sprite = new Power Up Fire Flower anim  / Um Thread Pool é um grupo com quantidade limitada de Threads que são usadas para executar tarefas @author David Buzatto / public Thread Pool extends Thread Group private boolean is Alive private Linked List< Runnable > task Queue private int thread ID private static int thread Pool ID protected void thread Started protected void thread Stopped / Cria um novo Pool de Threads @param num Threads O número de threads no pool / public Thread Pool int num Threads super Thread Pool- + thread Pool ID++ set Daemon true is Alive = true task Queue = new Linked List< Runnable > for int i = 0 i < num Threads i++ new Pooled Thread start / Requisita uma nova tarefa para ser executada Este método retorna imediatamente e a tarefa executa na próxima thread parada no pool de threads / public synchronized void run Task Runnable task if !is Alive throw new Illegal State Exception if task != null task Queue add task notify protected synchronized Runnable get Task throws Interrupted Exception while task Queue size == 0 if !is Alive return null wait return task Queue remove First / Fecha este pool de threads e retorna imediatamente Todas as thredas são paradas e todas as tarefas que estão aguardando não são executadas Quando o pool é fechado mais nenhuma outra tarefa pode ser executada nesse pool / public synchronized void close if is Alive is Alive = false task Queue clear interrupt / Fecha este pool de threads e aguarda que todas as threads que estão executando sejam finalizadas Todas as tarefas que estão aguardando são executadas / public void join / notifica todas as threads que estão aguardando que este pool não está mais vivo / synchronized this is Alive = false notify All aguarda todas as thredas terminarem Thread[] threads = new Thread[ active Count ] int count = enumerate threads for int i = 0 i < count i++ try threads[ i ] join catch Interrupted Exception exc / Uma Pooled Thread é uma Thread no grupo da Thread Pool desenhada para executar tarefas / private Pooled Thread extends Thread public Pooled Thread super Thread Pool this Pooled Thread- + thread ID++ @ Override public void run while !is Interrupted try obtém uma tarefa para executar Runnable task = null try thread Started task = get Task catch Interrupted Exception exc / se o get Task retorna num ou está interrompido fecha esta thread retornando / if task == null return executa a thread e come qualquer excessão que esta lance try task run catch Throwable t uncaught Exception this t finally thread Stopped  / A e Game Manager gerencia todas as partes do jogo @author David Buzatto / public Game Manager extends Game Core public static void main [] args new Game Manager run descomprimido 11025 Hz 8-bit mono signed little-endian private static final Audio Format PLAYBACK_ FORMAT = new Audio Format 11025 8 1 true false quantidade máxima de fases importante para a finalização private static int QUANTIDADE_ FASES = 3 private static final int DRUM_ TRACK = 1 public static final float GRAVITY = 0 002f indica se o jogo está pausado private boolean paused indica se deve ir para a próxima fase private boolean go To Next Level indica que o jogo terminou private boolean game Over private Point point Cache = new Point private Tile Map map private Midi Player midi Player Musica private Midi Player midi Player Musica Final Fase private Midi Player midi Player Musica Game Over private Sound Manager sound Manager private Resource Manager resource Manager private Sound coin Sound private Sound stomp Sound private Sound one Up Sound private Sound death Sound private Sound jump Sound private Sound power Up Sound private Sound power Down Sound private Sequence musica private Sequence musica Final Fase private Sequence musica Game Over private Input Manager input Manager private Tile Map Renderer renderer ações private Game Action move Left private Game Action move Right private Game Action move Down private Game Action jump private Game Action exit private Game Action run private Game Action config Action private Game Action pause contadores da interface private int quantidade Vidas private int quantidade Pontos private int quantidade Pontos Fase private int quantidade Coins private int quantidade Estrelas contadores de quadros private int quadros Abertura private int quadros Fechamento private int quadros Game Over private int quadro Atual Abertura private int quadro Atual Fechamento private int quadro Atual Game Over imagens da interface private Image imagem Interface Mario private Image imagem Interface Star private Image imagem Interface Coin private Image imagem Interface Pontuacao private Image imagem Interface Total private Image imagem Interface Pausa private Image imagem Interface Estagio Finalizado private Image imagem Interface Jogo Finalizado private Image imagem Interface Game Over private Image imagem Interface X private Image imagem Interface0 private Image imagem Interface1 private Image imagem Interface2 private Image imagem Interface3 private Image imagem Interface4 private Image imagem Interface5 private Image imagem Interface6 private Image imagem Interface7 private Image imagem Interface8 private Image imagem Interface9 public void init super init assegura que os componentes Swing não irão se pintar Null Repaint Manager install inicia o input manager init Input configura como não pausado set Paused false configura se é para ir para a próxima fase set Go To Next Level false configura que o jogo não terminou set Game Over false inicia o resource manager resource Manager = new Resource Manager screen get Full Screen Window get Graphics Configuration Z carrega os recursos renderer = new Tile Map Renderer renderer set Background resource Manager load Image background + quantidade Estrelas + png carrega o primeiro mapa map = resource Manager load Next Map carrega os sons sound Manager = new Sound Manager PLAYBACK_ FORMAT coin Sound = sound Manager get Sound smw_coin wav stomp Sound = sound Manager get Sound smw_stomp wav one Up Sound = sound Manager get Sound smw_1-up wav death Sound = sound Manager get Sound smw_death wav jump Sound = sound Manager get Sound smw_jump wav power Up Sound = sound Manager get Sound smw_powerup wav power Down Sound = sound Manager get Sound smw_powerdown wav inicia os contadores do jogo quantidade Vidas = 5 quantidade Coins = 0 quantidade Pontos = 0 quantidade Pontos Fase = 0 quantidade Estrelas = 0 inicia os contadores de animação quadros Abertura = 50 quadro Atual Abertura = 0 zerado fazer animação na carga do jogo quadros Fechamento = 50 quadro Atual Fechamento = quadros Fechamento quadros Game Over = 120 quadro Atual Game Over = 0 carrega as imagens imagem Interface Mario = resource Manager load Image interface Mario png imagem Interface Star = resource Manager load Image interface Star png imagem Interface Coin = resource Manager load Image interface Coin png imagem Interface Pontuacao = resource Manager load Image interface Pontuacao png imagem Interface Total = resource Manager load Image interface Total png imagem Interface Pausa = resource Manager load Image interface Pausa png imagem Interface Estagio Finalizado = resource Manager load Image interface Estagio Finalizado png imagem Interface Jogo Finalizado = resource Manager load Image interface Jogo Finalizado png imagem Interface Game Over = resource Manager load Image interface Game Over png imagem Interface X = resource Manager load Image interface X png imagem Interface0 = resource Manager load Image interface0 png imagem Interface1 = resource Manager load Image interface1 png imagem Interface2 = resource Manager load Image interface2 png imagem Interface3 = resource Manager load Image interface3 png imagem Interface4 = resource Manager load Image interface4 png imagem Interface5 = resource Manager load Image interface5 png imagem Interface6 = resource Manager load Image interface6 png imagem Interface7 = resource Manager load Image interface7 png imagem Interface8 = resource Manager load Image interface8 png imagem Interface9 = resource Manager load Image interface9 png inicia a música midi Player Musica = new Midi Player midi Player Musica Final Fase = new Midi Player midi Player Musica Game Over = new Midi Player musica = midi Player Musica get Sequence music + quantidade Estrelas + midi musica Final Fase = midi Player Musica Final Fase get Sequence music Level End midi musica Game Over = midi Player Musica Game Over get Sequence music Game Over midi midi Player Musica play musica true toggle Drum Playback / Fecha os recursos usados pelo Game Manager / public void stop super stop midi Player Musica close sound Manager close private void init Input move Left = new Game Action move Left move Right = new Game Action move Right move Down = new Game Action move Down jump = new Game Action jump Game Action DETECT_ INITAL_ PRESS_ ONLY exit = new Game Action exit Game Action DETECT_ INITAL_ PRESS_ ONLY run = new Game Action run config Action = new Game Action config Game Action DETECT_ INITAL_ PRESS_ ONLY pause = new Game Action pause Game Action DETECT_ INITAL_ PRESS_ ONLY input Manager = new Input Manager screen get Full Screen Window input Manager set Cursor Input Manager INVISIBLE_ CURSOR input Manager map To Key move Left Key Event VK_ LEFT input Manager map To Key move Right Key Event VK_ RIGHT input Manager map To Key move Down Key Event VK_ DOWN input Manager map To Key jump Key Event VK_ SPACE input Manager map To Key exit Key Event VK_ ESCAPE input Manager map To Key run Key Event VK_ CONTROL input Manager map To Key pause Key Event VK_ P input Manager map To Key config Action Key Event VK_ C private void check Input long elapsed Time if exit is Pressed stop Player player = Player map get Player if player is Alive float velocity X = 0 if move Left is Pressed && !player is Down velocity X -= player get Max Speed if move Right is Pressed && !player is Down velocity X += player get Max Speed if move Down is Pressed player set Down true else player set Down false if jump is Pressed toca apenas se o jogador não estiver pulando if !player is Pulando sound Manager play jump Sound player jump false verifica se é para correr if run is Pressed player set Max Speed 0 5f else player set Max Speed 0 3f se a pausa for pressionada e as animações de abertura/fechamento não estiverem sendo executadas if pause is Pressed && quadro Atual Abertura == quadros Abertura && quadro Atual Fechamento == quadros Fechamento set Paused !is Paused se estiver pausado para a música if is Paused se o player não estiver pausado pausa if !midi Player Musica is Paused midi Player Musica stop else midi Player Musica play musica true if config Action is Pressed TODO - implementar configuração System out implementar player set Velocity X velocity X public void draw Graphics2 D g renderer draw g map screen get Width screen get Height desenha a interface gráfica draw Interface g desenha a animação de abertura de tela if quadro Atual Abertura < quadros Abertura && !is Go To Next Level draw Abertura g desenha a animação de fechamento de tela if quadro Atual Fechamento < quadros Fechamento && !is Go To Next Level draw Fechamento g desenha a tela de passagem de fase transferência de pontos if is Go To Next Level draw Point Transfer g desenha tela de fim de jogo if is Game Over draw Game Over g desenha a animação de pausa if is Paused draw Pause g / Obtém o mapa atual / public Tile Map get Map return map / Liga/desliga as baterias no midi track1 / public void toggle Drum Playback Sequencer sequencer = midi Player Musica get Sequencer if sequencer != null sequencer set Track Mute DRUM_ TRACK !sequencer get Track Mute DRUM_ TRACK / Obtém o tile que a Sprite colide Somente X ou Y da Sprite deve ser mudado não ambos Retorna null se nenhuma colisão for detectada / public Point get Tile Collision Sprite sprite float new X float new Y float from X = Math min sprite get X new X float from Y = Math min sprite get Y new Y float to X = Math max sprite get X new X float to Y = Math max sprite get Y new Y obtem a localização do tile int from Tile X = Tile Map Renderer pixels To Tiles from X int from Tile Y = Tile Map Renderer pixels To Tiles from Y int to Tile X = Tile Map Renderer pixels To Tiles to X + sprite get Width - 1 int to Tile Y = Tile Map Renderer pixels To Tiles to Y + sprite get Height - 1 checa cada tile para verificar a colisão for int x = from Tile X x <= to Tile X x++ for int y = from Tile Y y <= to Tile Y y++ if x < 0 || x >= map get Width || map get Tile x y != null colisão achada retorna o tile point Cache set Location x y return point Cache nenhuma colisão achada return null / Verifica se duas sprites colidiram entre si Retorna false caso duas Sprites sejam a mesma Retorna false se um uma das Sprites não estiver viva / public boolean is Collision Sprite s1 Sprite s2 se as sprites são a mesma retorn false if s1 == s2 return false se uma das sprites é uma criatura morta retorna false if s1 instanceof Creature && ! Creature s1 is Alive return false if s2 instanceof Creature && ! Creature s2 is Alive return false obtem a localização em pixel das sprites int s1x = Math round s1 get X int s1y = Math round s1 get Y int s2x = Math round s2 get X int s2y = Math round s2 get Y verifica se as bordas das sprites se interceptam return s1x < s2x + s2 get Width && s2x < s1x + s1 get Width && s1y < s2y + s2 get Height && s2y < s1y + s1 get Height / Obtém a Sprite que colide com uma Sprite específica ou null se nenhum Sprite colide com a Sprite especificada / public Sprite get Sprite Collision Sprite sprite itera pela lista de sprites Iterator i = map get Sprites while i has Next Sprite other Sprite = Sprite i next if is Collision sprite other Sprite colisão encontrada retorna a sprite return other Sprite sem colisão return null / Atualiza a animação posição e velocidade de todas as sprites do mapa atual / public void update long elapsed Time Creature player = Creature map get Player jogador está morto reinicia o mapa if player get State == Creature STATE_ DEAD se não há mais vidas mostra a tela de fim de jogo e termina if quantidade Vidas == 0 set Game Over true else prepara abertura quadro Atual Abertura = 0 recarrega o mapa atual map = resource Manager reload Map reinicia o som midi Player Musica play musica true reseta os contadores de pontuação quantidade Coins = 0 quantidade Pontos Fase = 0 return verifica a entrada do teclado/mouse check Input elapsed Time verifica se está pausado if !is Paused && !is Go To Next Level atualiza o jogador update Creature player elapsed Time player update elapsed Time atualiza as outras sprites Iterator i = map get Sprites while i has Next Sprite sprite = Sprite i next if sprite instanceof Creature Creature creature = Creature sprite if creature get State == Creature STATE_ DEAD i remove else update Creature creature elapsed Time atualização normal sprite update elapsed Time / Atualiza as criaturas usando gravidade para as criaturas que não estão voando e verifica colisão / private void update Creature Creature creature long elapsed Time usa gravidade if !creature is Flying creature set Velocity Y creature get Velocity Y + GRAVITY elapsed Time altera x float dx = creature get Velocity X float old X = creature get X float new X = old X + dx elapsed Time Point tile = get Tile Collision creature new X creature get Y if tile == null creature set X new X else alinha com a borda do tile if dx > 0 creature set X Tile Map Renderer tiles To Pixels tile x - creature get Width else if dx < 0 creature set X Tile Map Renderer tiles To Pixels tile x + 1 creature collide Horizontal if creature instanceof Player check Player Collision Player creature false troca y float dy = creature get Velocity Y float old Y = creature get Y float new Y = old Y + dy elapsed Time tile = get Tile Collision creature creature get X new Y if tile == null creature set Y new Y else alinha com a borda do tile if dy > 0 creature set Y Tile Map Renderer tiles To Pixels tile y - creature get Height else if dy < 0 creature set Y Tile Map Renderer tiles To Pixels tile y + 1 creature collide Vertical if creature instanceof Player boolean can Kill = old Y < creature get Y check Player Collision Player creature can Kill se o jogador cai y muito alto tira vida e reinicia if creature instanceof Player se o jogador está além do pixel 2000 de altura morre if creature get Y > 2000 se tem vidas if quantidade Vidas != 0 pára a música midi Player Musica stop reproduz o som sound Manager play death Sound creature set State creature STATE_ DEAD quantidade Vidas-- dorme por 4 segundos para esperar a música ser reproduzida try Thread sleep 4000 catch Interrupted Exception exc prepara fechamento quadro Atual Fechamento = 0 / Verifica colisão entre o jogador e outras sprites If can Kill é true a colisão com as criaturas irá matá-las / public void check Player Collision Player player boolean can Kill if !player is Alive return verifica a colisão do jogador com outras Sprites Sprite collision Sprite = get Sprite Collision player if collision Sprite instanceof Power Up acquire Power Up Power Up collision Sprite else if collision Sprite instanceof Creature Creature badguy = Creature collision Sprite if can Kill mata o inimigo a faz o jogador oscilar sound Manager play stomp Sound badguy set State Creature STATE_ DYING quantidade Pontos Fase += 100 player set Y badguy get Y - player get Height player jump true else jogador morre player set State Creature STATE_ DYING decrementa quantidade de vidas quantidade Vidas-- pára a música midi Player Musica stop reproduz o som sound Manager play death Sound prepara fechamento quadro Atual Fechamento = 0 / Dá ao jogador o power Up especificado e remove o mesmo do mapa / public void acquire Power Up Power Up power Up remove do mapa map remove Sprite power Up if power Up instanceof Power Up Coin soma 10 pontos quantidade Pontos Fase += 10 soma um coin quantidade Coins += 1 reproduz o som sound Manager play coin Sound se tiver uma quantidade múltipla de 100 if quantidade Coins % 100 == 0 ganha uma vida quantidade Vidas++ reproduz o som sound Manager play one Up Sound else if power Up instanceof Power Up Mushroom soma 1000 pontos quantidade Pontos Fase += 1000 altera a música sound Manager play coin Sound reproduz o som sound Manager play power Up Sound else if power Up instanceof Power Up Fire Flower soma 1000 pontos quantidade Pontos Fase += 1000 else if power Up instanceof Power Up One Up soma 1000 pontos quantidade Pontos Fase += 1000 soma 1 vida quantidade Vidas++ reproduz o som sound Manager play one Up Sound else if power Up instanceof Power Up Goal soma uma estrela quantidade Estrelas++ prepara fechamento quadro Atual Abertura = 0 avança no mapa sound Manager play power Up Sound sinaliza para ir para a próxima fase set Go To Next Level true pára a música e toca a música de nova fase midi Player Musica stop midi Player Musica Final Fase play musica Final Fase false midi Player2 a responsabilidade de ir para o próximo mapa e carregar o fundo é fo método draw Point Transfer / Método para desenhar a interface gráfica / private void draw Interface Graphics2 D g2d g2d set Rendering Hint Rendering Hints KEY_ ANTIALIASING Rendering Hints VALUE_ ANTIALIAS_ ON g2d draw Image imagem Interface Mario 20 20 null g2d draw Image imagem Interface X 30 40 null monta Numero g2d quantidade Vidas 50 42 0 g2d draw Image imagem Interface Star 150 22 null g2d draw Image imagem Interface X 170 22 null monta Numero g2d quantidade Estrelas 190 24 0 g2d draw Image imagem Interface Coin 280 22 null g2d draw Image imagem Interface X 300 22 null monta Numero g2d quantidade Coins 320 24 0 g2d draw Image imagem Interface Pontuacao 410 22 null g2d draw Image imagem Interface X 420 40 null monta Numero g2d quantidade Pontos Fase 440 42 0 g2d draw Image imagem Interface Total 560 22 null g2d draw Image imagem Interface X 570 40 null monta Numero g2d quantidade Pontos 590 42 0 / Método que recebe um inteiro e monta as imagens correspondentes / private void monta Numero Graphics2 D g2d int numero int x int y int kern char[] n = value Of numero to Char Array for int i = 0 i < n length i++ switch n[ i ] case 0 : g2d draw Image imagem Interface0 x y null x += imagem Interface0 get Width null + kern break case 1 : g2d draw Image imagem Interface1 x y null x += imagem Interface1 get Width null + kern break case 2 : g2d draw Image imagem Interface2 x y null x += imagem Interface2 get Width null + kern break case 3 : g2d draw Image imagem Interface3 x y null x += imagem Interface3 get Width null + kern break case 4 : g2d draw Image imagem Interface4 x y null x += imagem Interface4 get Width null + kern break case 5 : g2d draw Image imagem Interface5 x y null x += imagem Interface5 get Width null + kern break case 6 : g2d draw Image imagem Interface6 x y null x += imagem Interface6 get Width null + kern break case 7 : g2d draw Image imagem Interface7 x y null x += imagem Interface7 get Width null + kern break case 8 : g2d draw Image imagem Interface8 x y null x += imagem Interface8 get Width null + kern break case 9 : g2d draw Image imagem Interface9 x y null x += imagem Interface9 get Width null + kern break / Desenha o que deve aparecer durante a pausa / private void draw Pause Graphics2 D g2d int largura = screen get Full Screen Window get Width int altura = screen get Full Screen Window get Height g2d set Color new Color 0 0 0 50 g2d fill Rect 0 0 largura altura g2d draw Image imagem Interface Pausa largura / 2 - imagem Interface Pausa get Width null / 2 altura / 2 - imagem Interface Pausa get Height null / 2 null / Desenha a abertura de tela início e reinício de fase / private void draw Abertura Graphics2 D g2d int largura = screen get Full Screen Window get Width int altura = screen get Full Screen Window get Height int passo L = largura / quadros Abertura int passo A = altura / quadros Abertura g2d set Color Color BLACK g2d fill Rect largura - quadros Abertura passo L - quadro Atual Abertura passo L / 2 altura - quadros Abertura passo A - quadro Atual Abertura passo A / 2 quadros Abertura passo L - quadro Atual Abertura passo L quadros Abertura passo A - quadro Atual Abertura passo A quadro Atual Abertura++ / Desenha o fechamento de tela quando morre ou quando passa de fase / private void draw Fechamento Graphics2 D g2d int largura = screen get Full Screen Window get Width int altura = screen get Full Screen Window get Height int passo L = largura / quadros Fechamento int passo A = altura / quadros Fechamento g2d set Color Color BLACK g2d fill Rect largura / 2 - quadro Atual Fechamento passo L / 2 altura / 2 - quadro Atual Fechamento passo A / 2 quadro Atual Fechamento passo L quadro Atual Fechamento passo A quadro Atual Fechamento++ / Desenha a transferência de pontos / private void draw Point Transfer Graphics2 D g2d g2d set Color Color BLACK int largura = screen get Full Screen Window get Width int altura = screen get Full Screen Window get Height int x Cabecalho = largura / 2 - imagem Interface Estagio Finalizado get Width null / 2 int x Jogo = largura / 2 - imagem Interface Jogo Finalizado get Width null / 2 int x Pontuacao = largura / 2 - imagem Interface Pontuacao get Width null / 2 pára a música if !midi Player Musica is Paused midi Player Musica stop desenha o retângulo preto g2d fill Rect 0 0 largura altura if quantidade Estrelas != QUANTIDADE_ FASES g2d draw Image imagem Interface Estagio Finalizado x Cabecalho 100 null else g2d draw Image imagem Interface Jogo Finalizado x Jogo 100 null g2d draw Image imagem Interface Pontuacao x Pontuacao altura / 2 - 20 null g2d draw Image imagem Interface X x Pontuacao + 20 altura / 2 - 20 + 18 null monta Numero g2d quantidade Pontos Fase x Pontuacao + 40 altura / 2 - 20 + 20 0 g2d draw Image imagem Interface Total x Pontuacao altura / 2 + 30 null g2d draw Image imagem Interface X x Pontuacao + 20 altura / 2 + 48 null monta Numero g2d quantidade Pontos x Pontuacao + 40 altura / 2 + 50 0 transfere os pontos if quantidade Pontos Fase > 0 quantidade Pontos += 10 quantidade Pontos Fase -= 10 sound Manager play coin Sound se ja transferiu os pontos e se a espera terminou carrega próxima fase if quantidade Pontos Fase == 0 && !midi Player Musica Final Fase get Sequencer is Running sinaliza para ir para a próxima fase set Go To Next Level false seta o fundo renderer set Background resource Manager load Image background + quantidade Estrelas + png carrega o próximo mapa map = resource Manager load Next Map para a música do final midi Player Musica Final Fase stop troca a música musica = midi Player Musica get Sequence music + quantidade Estrelas + midi coloca a música para rodar de novo midi Player Musica play musica true zera as moedas quantidade Coins = 0 / Desenha a tela de fim de jogo / private void draw Game Over Graphics2 D g2d g2d set Color Color BLACK int largura = screen get Full Screen Window get Width int altura = screen get Full Screen Window get Height int x = largura / 2 - imagem Interface Game Over get Width null / 2 int y = largura / 2 - imagem Interface Game Over get Width null / 2 pára a música if !midi Player Musica is Paused midi Player Musica stop toca a música de game over if midi Player Musica Game Over is Paused midi Player Musica Game Over play musica Game Over false desenha o retângulo preto g2d fill Rect 0 0 largura altura g2d draw Image imagem Interface Game Over x y null se todos os quadros já passaram finaliza o jogo if quadro Atual Game Over == quadros Game Over stop incrementa o quadro atual do fim de jogo quadro Atual Game Over++ / Faz pausar a execução / public void set Paused boolean p if is Paused != p this paused = p input Manager reset All Game Actions public boolean is Paused return paused public boolean is Go To Next Level return go To Next Level public void set Go To Next Levelboolean go To Next Level this go To Next Level = go To Next Level public boolean is Game Over return game Over public void set Game Overboolean game Over this game Over = game Over  / Uma Bat é uma Creature que voa vagarozamente no ar / public Bat extends Creature public Bat Animation left Animation right Animation dead Left Animation dead Right super left right dead Left dead Right set Max Speed 0 2f public boolean is Flying return is Alive  / Um Blue Dragon é uma Creature que se move devagar no chão / public Blue Dragon extends Creature public Blue Dragon Animation left Animation right Animation dead Left Animation dead Right super left right dead Left dead Right set Max Speed 0 1f  / Um Blue Koopa é uma Creature que se move devagar no chão / public Blue Koopa extends Creature public Blue Koopa Animation left Animation right Animation dead Left Animation dead Right super left right dead Left dead Right set Max Speed 0 1f  / Um Bomb é uma Creature que se move devagar no chão / public Bomb extends Creature public Bomb Animation left Animation right Animation dead Left Animation dead Right super left right dead Left dead Right set Max Speed 0 1f  / Uma Bullet é uma Creature que voa vagarozamente no ar / public Bullet extends Creature public Bullet Animation left Animation right Animation dead Left Animation dead Right super left right dead Left dead Right set Max Speed 0 25f public boolean is Flying return is Alive  / Uma Creature é uma Sprite que é afetada pela gravidade e pode morrer Ela tem quatro animações: moveno para a esquerda direita morrendo para a esquerda e direita @author David Buzatto / public abstract Creature extends Sprite / Quantidade de tempo para ir de STATE_ DYING para STATE_ DEAD / public static final int DIE_ TIME = 500 public static final int STATE_ NORMAL = 0 public static final int STATE_ DYING = 1 public static final int STATE_ DEAD = 2 private Animation left private Animation right private Animation dead Left private Animation dead Right private int state private long state Time private float max Speed / Cria uma nova criatura com as animações especificadas / public Creature Animation left Animation right Animation dead Left Animation dead Right super right this set Left left this set Right right this set Dead Left dead Left this set Dead Right dead Right this set Max Speed 0 set State STATE_ NORMAL public Object clone usa reflexão para criar a sub e correta Constructor constructor = get Class get Constructors[ 0 ] try return constructor new Instance new Object[] Animation get Left clone Animation get Right clone Animation get Dead Left clone Animation get Dead Right clone catch Exception ex provavelmente nunca deve ocorrer ex print Stack Trace return null / Configura a velocidade máxima dessa criatura / public void set Max Speed float max Speed this max Speed = max Speed / Obtém a velocidade máxima dessa criatura / public float get Max Speed return max Speed / Acorda a criatura quanto esta aparece pela primeira vez na tela Normalmente a criatura inicia movimentando-se para a esquerda / public void wake Up if get State == STATE_ NORMAL && get Velocity X == 0 set Velocity X -get Max Speed / Obtém o estado dessa criatura podendo ser STATE_ NORMAL STATE_ DYING ou STATE_ DEAD / public int get State return state / Configura o estado dessa criatura para STATE_ NORMAL STATE_ DYING ou STATE_ DEAD / public void set State int state if this state != state this state = state set State Time0 if state == STATE_ DYING set Velocity X 0 set Velocity Y 0 / Verifica se essa criatura está viva / public boolean is Alive return get State == STATE_ NORMAL / Verifica se esta criatura está voando / public boolean is Flying return false / Chamado antes de update se a criatura colidiu com um tile horizontalmente / public void collide Horizontal set Velocity X -get Velocity X / Chamado antes de update se a criatura colidiu com um tile verticalmente / public void collide Vertical set Velocity Y0 / Atualiza a animação dessa criatura / public void update long elapsed Time seleciona a animação correta Animation new Anim = anim if get Velocity X < 0 new Anim = get Left else if get Velocity X > 0 new Anim = get Right if get State == STATE_ DYING && new Anim == get Left new Anim = get Dead Left else if get State == STATE_ DYING && new Anim == get Right new Anim = get Dead Right atualiza a animação if anim != new Anim anim = new Anim anim start else anim update elapsed Time atualiza o estado de morte set State Timeget State Time + elapsed Time if state == STATE_ DYING && get State Time >= DIE_ TIME set State STATE_ DEAD public Animation get Left return left public void set Left Animation left this left = left public Animation get Right return right public void set Right Animation right this right = right public Animation get Dead Left return dead Left public void set Dead Left Animation dead Left this dead Left = dead Left public Animation get Dead Right return dead Right public void set Dead Right Animation dead Right this dead Right = dead Right public long get State Time return state Time public void set State Timelong state Time this state Time = state Time  / Uma Fly Goomba é uma Creature que voa vagarozamente no ar / public Fly Goomba extends Creature public Fly Goomba Animation left Animation right Animation dead Left Animation dead Right super left right dead Left dead Right set Max Speed 0 2f public boolean is Flying return is Alive  / Um Goomba é uma Creature que se move devagar no chão / public Goomba extends Creature public Goomba Animation left Animation right Animation dead Left Animation dead Right super left right dead Left dead Right set Max Speed 0 1f  / Um Green Koopa é uma Creature que se move devagar no chão / public Green Koopa extends Creature public Green Koopa Animation left Animation right Animation dead Left Animation dead Right super left right dead Left dead Right set Max Speed 0 1f  / Um Mummy Turtle é uma Creature que se move devagar no chão / public Mummy Turtle extends Creature public Mummy Turtle Animation left Animation right Animation dead Left Animation dead Right super left right dead Left dead Right set Max Speed 0 1f  / O jogador @author David Buzatto / public Player extends Creature private static final float JUMP_ SPEED = - 77f private boolean on Ground variáveis de controle indica se está virado para a direita private boolean turned To Right indica se está abaixado private boolean down indica se está pulando private boolean pulando private Animation run Left private Animation run Right private Animation jump Left private Animation jump Right private Animation down Left private Animation down Right public Player Animation left Animation right Animation dead Left Animation dead Right Animation run Left Animation run Right Animation jump Left Animation jump Right Animation down Left Animation down Right super left right dead Left dead Right this set Run Left run Left this set Run Right run Right this set Jump Left jump Left this set Jump Right jump Right this set Down Left down Left this set Down Right down Right turned To Right = true set Max Speed 0 1f set Down false public Object clone usa reflexão para criar a sub e correta Constructor constructor = get Class get Constructors[ 0 ] try return constructor new Instance new Object[] Animation get Left clone Animation get Right clone Animation get Dead Left clone Animation get Dead Right clone Animation get Run Left clone Animation get Run Right clone Animation get Jump Left clone Animation get Jump Right clone Animation get Down Left clone Animation get Down Right clone catch Exception ex provavelmente nunca deve ocorrer ex print Stack Trace return null public void collide Horizontal set Velocity X 0 public void collide Vertical verifica se colidiu com o chão if get Velocity Y > 0 on Ground = true set Pulando false set Velocity Y 0 public void set Yfloat y verifica se está caindo if Math round y > Math round get Y on Ground = false super set Y y public void wake Up não faz nada / Faz o jogador pular se o mesmo estiver no chão ou então se force Jump é true / public void jump boolean force Jump if on Ground || force Jump on Ground = false set Velocity Y JUMP_ SPEED if !on Ground set Pulando true else set Pulando false / Atualiza a animação desse jogador / public void update long elapsed Time seleciona a animação correta Animation new Anim = anim if get Velocity X < 0 if !is Pulando new Anim = get Run Left turned To Right = false else if get Velocity X > 0 if !is Pulando new Anim = get Run Right turned To Right = true else if turned To Right if is Down new Anim = get Down Right else if is Pulando new Anim = get Jump Right else new Anim = get Right else if is Down new Anim = get Down Left else if is Pulando new Anim = get Jump Left else new Anim = get Left if get Velocity Y < 0 if turned To Right new Anim = jump Right else new Anim = jump Left set Pulando true if get State == STATE_ DYING && new Anim == get Left new Anim = get Dead Left else if get State == STATE_ DYING && new Anim == get Right new Anim = get Dead Right atualiza a animação if anim != new Anim anim = new Anim anim start else anim update elapsed Time atualiza o estado de morte set State Time get State Time + elapsed Time if get State == STATE_ DYING && get State Time >= 3500 set State STATE_ DEAD public boolean is Down return down public void set Downboolean down this down = down public boolean is Pulando return pulando public void set Pulandoboolean pulando this pulando = pulando public Animation get Run Left return run Left public void set Run Left Animation run Left this run Left = run Left public Animation get Run Right return run Right public void set Run Right Animation run Right this run Right = run Right public Animation get Jump Left return jump Left public void set Jump Left Animation jump Left this jump Left = jump Left public Animation get Jump Right return jump Right public void set Jump Right Animation jump Right this jump Right = jump Right public Animation get Down Left return down Left public void set Down Left Animation down Left this down Left = down Left public Animation get Down Right return down Right public void set Down Right Animation down Right this down Right = down Right  / Power Up é uma Sprite que o jogador pode pegar / public abstract Power Up extends Sprite public Power Up Animation anim super anim public Object clone usa reflexão para criar a sub e correta Constructor constructor = get Class get Constructors[ 0 ] try return constructor new Instance new Object[] Animationanim clone catch Exception ex provavelmente nunca irá acontecer ex print Stack Trace return null / O Power Up Coin Dá pontos ao jogador / public static Coin extends Power Up public Coin Animation anim super anim / O Power Up Mushroom faz o jogador crescer / public static Mushroom extends Power Up public Mushroom Animation anim super anim / O Power Up One Upe dá uma vida ao jogador / public static One Up extends Power Up public One Up Animation anim super anim / O Power Up Fire Flower dá ao jogador poder de jogar fogo / public static Fire Flower extends Power Up public Fire Flower Animation anim super anim / O Power Up Goal Avança para o próximo mapa / public static Goal extends Power Up public Goal Animation anim super anim  / Um Red Koopa é uma Creature que se move devagar no chão / public Red Koopa extends Creature public Red Koopa Animation left Animation right Animation dead Left Animation dead Right super left right dead Left dead Right set Max Speed 0 1f  / Um Turtle é uma Creature que se move devagar no chão / public Turtle extends Creature public Turtle Animation left Animation right Animation dead Left Animation dead Right super left right dead Left dead Right set Max Speed 0 1f  / Um Yellow Koopa é uma Creature que se move devagar no chão / public Yellow Koopa extends Creature public Yellow Koopa Animation left Animation right Animation dead Left Animation dead Right super left right dead Left dead Right set Max Speed 0 1f  / A e Tile Map contém a informação para um pequeno mapa de figuras lado a lado incluindo Sprites Cada pedaço é uma referência a uma imagem sendo essas imagens usadas múltiplas vezes no mesmo mapa @author David Buzatto / public Tile Map private Image[][] tiles private Linked List< Sprite > sprites private Sprite player / Cria um novo Tile Map com a largura e altura especificada em número de pedaços do mapa / public Tile Map int width int height tiles = new Image[ width ][ height ] sprites = new Linked List< Sprite > / Obtém a largura do Tile Map número de pedaços / public int get Width return tiles length / Obtém a altura do Tile Map número de pedaços / public int get Height return tiles[ 0 ] length / Obtém o pedaço de uma localização espefífica Retorna null is não haver nenhum pedaço na localização espeficada ou então se a localizaçãono for fora dos limites do mapa / public Image get Tile int x int y if x < 0 || x >= get Width || y < 0 || y >= get Height return null else return tiles[ x ][ y ] / Configura o pedaço no local especificado / public void set Tile int x int y Image tile tiles[ x ][ y ] = tile / Obtém a Sprite do jogador / public Sprite get Player return player / Configura a Sprite do jogador / public void set Player Sprite player this player = player / Adiciona a Sprite no mapa / public void add Sprite Sprite sprite sprites add sprite / Remove a Sprite do mapa / public void remove Sprite Sprite sprite sprites remove sprite / Obtém o Iterator de todas as Sprites desse mapa menos a do jogador / public Iterator get Sprites return sprites iterator  / A e Tile Map Renderer desenha um Tile Map na tela Ela desenha todos os tiles sprites e o a imagem de fundo opcional centralizados na posição do jogador <p> Se a largura da imagem de fundo por menor que a largura do mapa a imagem de fundo parecerá que esta se movendo devagar criando o efeito de parallax <p> Também três métodos estáticos são fornecidos para converter pixels em posições dos tiles e vice-versa <p> Esse Tile Map Render usa tiles com tamanho de 64 / public Tile Map Renderer private static final int TILE_ SIZE = 32 o tamanho em bits do tile Math pow 2 TILE_ SIZE_ BITS == TILE_ SIZE private static final int TILE_ SIZE_ BITS = 5 private Image background / Converte uma posição em pixel para a posição de um tile / public static int pixels To Tiles float pixels return pixels To Tiles Math round pixels / Converte uma posição em pixel para a posição de um tile / public static int pixels To Tilesint pixels usa deslocamento para obter os valores corretos para pixels negativos return pixels >> TILE_ SIZE_ BITS ou se o tamanho dos tiles não forem potência de dois usa o método floor: return int Math floor float pixels / TILE_ SIZE / Converte a posição de um tile para a posição em pixel / public static int tiles To Pixelsint num Tiles sem razão real para usar deslocamento aqui o seu uso é um pouco mais rápido mas nos processadores modernos isso quase não faz diferença return num Tiles << TILE_ SIZE_ BITS se o tamanho dos tiles não forem potência de dois return num Tiles TILE_ SIZE / Configura o fundo para desenhar / public void set Background Image background this background = background / Desenha o Tile Map especificado / public void draw Graphics2 D g Tile Map map int screen Width int screen Height Sprite player = map get Player int map Width = tiles To Pixels map get Width obtém a posição de scrolling do mapa baseado na posição do jogador int offset X = screen Width / 2 - Math round player get X - TILE_ SIZE offset X = Math min offset X 0 offset X = Math max offset X screen Width - map Width obtém o offset de y para desenhar todas as sprites e tiles int offset Y = screen Height - tiles To Pixels map get Height desenha um fundo preto se necessário if background == null || screen Height > background get Height null g set Color Color BLACK g fill Rect 0 0 screen Width screen Height desenha a imagem de fundo usando parallax if background != null int x = offset X screen Width - background get Width null / screen Width - map Width int y = screen Height - background get Height null g draw Image background x y null desenha os tiles visíveis int first Tile X = pixels To Tiles -offset X int last Tile X = first Tile X + pixels To Tiles screen Width + 1 for int y = 0 y < map get Height y++ for int x = first Tile X x <= last Tile X x++ Image image = map get Tile x y if image != null g draw Image image tiles To Pixels x + offset X tiles To Pixels y + offset Y null desenha o jogador g draw Image player get Image Math round player get X + offset X Math round player get Y + offset Y null desenha as sprites Iterator i = map get Sprites while i has Next Sprite sprite = Sprite i next int x = Math round sprite get X + offset X int y = Math round sprite get Y + offset Y g draw Image sprite get Image x y null acorda a critura quando a mesma estiver na tela if sprite instanceof Creature && x >= 0 && x < screen Width Creature sprite wake Up 